(function () {
/**
	Basics
	======
    
    xui is available as the global `x$` function. It accepts a CSS selector string or DOM element, or an array of a mix of these, as parameters,
    and returns the xui object. For example:
    
        var header = x$('#header'); // returns the element with id attribute equal to "header".
        
    For more information on CSS selectors, see the [W3C specification](http://www.w3.org/TR/CSS2/selector.html). Please note that there are
    different levels of CSS selector support (Levels 1, 2 and 3) and different browsers support each to different degrees. Be warned!
    
	The functions described in the docs are available on the xui object and often manipulate or retrieve information about the elements in the
	xui collection.

*/
var undefined,
    xui,
    window     = this,
    string     = new String('string'), // prevents Goog compiler from removing primative and subsidising out allowing us to compress further
    document   = window.document,      // obvious really
    simpleExpr = /^#?([\w-]+)$/,   // for situations of dire need. Symbian and the such        
    idExpr     = /^#/,
    tagExpr    = /<([\w:]+)/, // so you can create elements on the fly a la x$('<img href="/foo" /><strong>yay</strong>')
    slice      = function (e) { return [].slice.call(e, 0); };
    try { var a = slice(document.documentElement.childNodes)[0].nodeType; }
    catch(e){ slice = function (e) { var ret=[]; for (var i=0; e[i]; i++) ret.push(e[i]); return ret; }; }

window.x$ = window.xui = xui = function(q, context) {
    return new xui.fn.find(q, context);
};

// patch in forEach to help get the size down a little and avoid over the top currying on event.js and dom.js (shortcuts)
if (! [].forEach) {
    Array.prototype.forEach = function(fn) {
        var len = this.length || 0,
            i = 0,
            that = arguments[1]; // wait, what's that!? awwww rem. here I thought I knew ya!
                                 // @rem - that that is a hat tip to your thats :)

        if (typeof fn == 'function') {
            for (; i < len; i++) {
                fn.call(that, this[i], i, this);
            }
        }
    };
}
/* 
 * Patch indexOf for internet explorer: http://soledadpenades.com/2007/05/17/arrayindexof-in-internet-explorer/ 
 */
if(!Array.indexOf){
  Array.prototype.indexOf = function(obj) {
    for(var i = 0; i < this.length; i++) {
      if(this[i] == obj){
          return i;
      }
    }
    return -1;
  }
}
/*
 * Array Remove - By John Resig (MIT Licensed) 
 */
function removex(array, from, to) {
    var rest = array.slice((to || from) + 1 || array.length);
    array.length = from < 0 ? array.length + from: from;
    return array.push.apply(array, rest);
}

// converts all CSS style names to DOM style names, i.e. margin-left to marginLeft
function domstyle(name) {
  return name.replace(/\-[a-z]/g,function(m) { return m.charAt(1).toUpperCase(); });
}

// converts all DOM style names to CSS style names, i.e. marginLeft to margin-left
function cssstyle(name) {
  return name.replace(/[A-Z]/g, function(m) { return '-'+m.toLowerCase(); })
}

xui.fn = xui.prototype = {

/**
	extend
	------

	Extends XUI's prototype with the members of another object.

	### syntax ###

		xui.extend( object );

	### arguments ###

	- object `Object` contains the members that will be added to XUI's prototype.
 
	### example ###

	Given:

		var sugar = {
		    first: function() { return this[0]; },
		    last:  function() { return this[this.length - 1]; }
		}

	We can extend xui's prototype with members of `sugar` by using `extend`:

		xui.extend(sugar);

	Now we can use `first` and `last` in all instances of xui:

		var f = x$('.button').first();
		var l = x$('.notice').last();
*/
    extend: function(o) {
        for (var i in o) {
            xui.fn[i] = o[i];
        }
    },

/**
	find
	----

	Find the elements that match a query string. `x$` is an alias for `find`.

	### syntax ###

		x$( window ).find( selector, context );

	### arguments ###

	- selector `String` is a CSS selector that will query for elements.
	- context `HTMLElement` is the parent element to search from _(optional)_.
 
	### example ###

	Given the following markup:

		<ul id="first">
		    <li id="one">1</li>
		    <li id="two">2</li>
		</ul>
		<ul id="second">
		    <li id="three">3</li>
		    <li id="four">4</li>
		</ul>

	We can select list items using `find`:

		x$('li');                 // returns all four list item elements.
		x$('#second').find('li'); // returns list items "three" and "four"
*/
    find: function(q, context) {
        var ele = [], tempNode;
            
        if (!q) {
            return this;
        } else if (context == undefined && this.length) {
            ele = this.each(function(el) {
                ele = ele.concat(slice(xui(q, el)));
            }).reduce(ele);
        } else {
            context = context || document;
            // fast matching for pure ID selectors and simple element based selectors
            if (typeof q == string) {
              if (simpleExpr.test(q) && context.getElementById && context.getElementsByTagName) {
                  ele = idExpr.test(q) ? [context.getElementById(q.substr(1))] : context.getElementsByTagName(q);
                  // nuke failed selectors
                  if (ele[0] == null) { 
                    ele = [];
                  }
              // match for full html tags to create elements on the go
              } else if (tagExpr.test(q)) {
                  tempNode = document.createElement('i');
                  tempNode.innerHTML = q;
                  slice(tempNode.childNodes).forEach(function (el) {
                    ele.push(el);
                  });
              } else {
                  // one selector, check if Sizzle is available and use it instead of querySelectorAll.
                  if (window.Sizzle !== undefined) {
                    ele = Sizzle(q, context);
                  } else {
                    ele = context.querySelectorAll(q);
                  }
              }
              // blanket slice
              ele = slice(ele);
            } else if (q instanceof Array) {
                ele = q;
            } else if (q.nodeName || q === window) { // only allows nodes in
                // an element was passed in
                ele = [q];
            } else if (q.toString() == '[object NodeList]' ||
q.toString() == '[object HTMLCollection]' || typeof q.length == 'number') {
                ele = slice(q);
            }
        }
        // disabling the append style, could be a plugin (found in more/base):
        // xui.fn.add = function (q) { this.elements = this.elements.concat(this.reduce(xui(q).elements)); return this; }
        return this.set(ele);
    },

/**
	set
	---

	Sets the objects in the xui collection.

	### syntax ###

		x$( window ).set( array );
*/
    set: function(elements) {
        var ret = xui();
        ret.cache = slice(this.length ? this : []);
        ret.length = 0;
        [].push.apply(ret, elements);
        return ret;
    },

/**
	reduce
	------

	Reduces the set of elements in the xui object to a unique set.

	### syntax ###

		x$( window ).reduce( elements, index );

	### arguments ###

	- elements `Array` is an array of elements to reduce _(optional)_.
	- index `Number` is the last array index to include in the reduction. If unspecified, it will reduce all elements _(optional)_.
*/
    reduce: function(elements, b) {
        var a = [],
        elements = elements || slice(this);
        elements.forEach(function(el) {
            // question the support of [].indexOf in older mobiles (RS will bring up 5800 to test)
            if (a.indexOf(el, 0, b) < 0)
            a.push(el);
        });

        return a;
    },

/**
	has
	---

	Returns the elements that match a given CSS selector.

	### syntax ###

		x$( window ).has( selector );

	### arguments ###

	- selector `String` is a CSS selector that will match all children of the xui collection.

	### example ###

	Given:

		<div>
		    <div class="round">Item one</div>
		    <div class="round">Item two</div>
		</div>
	
	We can use `has` to select specific objects:

		var divs    = x$('div');          // got all three divs.
		var rounded = divs.has('.round'); // got two divs with the class .round
*/
     has: function(q) {
         var list = xui(q);
         return this.filter(function () {
             var that = this;
             var found = null;
             list.each(function (el) {
                 found = (found || el == that);
             });
             return found;
         });
     },

/**
	filter
	------

	Extend XUI with custom filters. This is an interal utility function, but is also useful to developers.

	### syntax ###

		x$( window ).filter( fn );

	### arguments ###

	- fn `Function` is called for each element in the XUI collection.

	        // `index` is the array index of the current element
	        function( index ) {
	            // `this` is the element iterated on
	            // return true to add element to new XUI collection
	        }

	### example ###

	Filter all the `<input />` elements that are disabled:

		x$('input').filter(function(index) {
		    return this.checked;
		});
*/
    filter: function(fn) {
        var elements = [];
        return this.each(function(el, i) {
            if (fn.call(el, i)) elements.push(el);
        }).set(elements);
    },

/**
	not
	---

	The opposite of `has`. It modifies the elements and returns all of the elements that do __not__ match a CSS query.

	### syntax ###

		x$( window ).not( selector );

	### arguments ###

	- selector `String` a CSS selector for the elements that should __not__ be matched.

	### example ###

	Given:

		<div>
		    <div class="round">Item one</div>
		    <div class="round">Item two</div>
		    <div class="square">Item three</div>
		    <div class="shadow">Item four</div>
		</div>

	We can use `not` to select objects:

		var divs     = x$('div');          // got all four divs.
		var notRound = divs.not('.round'); // got two divs with classes .square and .shadow
*/
    not: function(q) {
        var list = slice(this),
            omittedNodes = xui(q);
        if (!omittedNodes.length) {
            return this;
        }
        return this.filter(function(i) {
            var found;
            omittedNodes.each(function(el) {
                return found = list[i] != el;
            });
            return found;
        });
    },

/**
	each
	----

	Element iterator for an XUI collection.

	### syntax ###

		x$( window ).each( fn )

	### arguments ###

	- fn `Function` callback that is called once for each element.

		    // `element` is the current element
		    // `index` is the element index in the XUI collection
		    // `xui` is the XUI collection.
		    function( element, index, xui ) {
		        // `this` is the current element
		    }

	### example ###

		x$('div').each(function(element, index, xui) {
		    alert("Here's the " + index + " element: " + element);
		});
*/
    each: function(fn) {
        // we could compress this by using [].forEach.call - but we wouldn't be able to support
        // fn return false breaking the loop, a feature I quite like.
        for (var i = 0, len = this.length; i < len; ++i) {
            if (fn.call(this[i], this[i], i, this) === false)
            break;
        }
        return this;
    }
};

xui.fn.find.prototype = xui.fn;
xui.extend = xui.fn.extend;
/**
	DOM
	===

	Set of methods for manipulating the Document Object Model (DOM).

*/
xui.extend({
/**
	html
	----

	Manipulates HTML in the DOM. Also just returns the inner HTML of elements in the collection if called with no arguments.

	### syntax ###

		x$( window ).html( location, html );

	or this method will accept just a HTML fragment with a default behavior of inner:

		x$( window ).html( html );

	or you can use shorthand syntax by using the location name argument as the function name:

		x$( window ).outer( html );
		x$( window ).before( html );
	
	or you can just retrieve the inner HTML of elements in the collection with:
	
	    x$( document.body ).html();

	### arguments ###

	- location `String` can be one of: _inner_, _outer_, _top_, _bottom_, _remove_, _before_ or _after_.
	- html `String` is a string of HTML markup or a `HTMLElement`.

	### example ###

		x$('#foo').html('inner', '<strong>rock and roll</strong>');
		x$('#foo').html('outer', '<p>lock and load</p>');
		x$('#foo').html('top',   '<div>bangers and mash</div>');
		x$('#foo').html('bottom','<em>mean and clean</em>');
		x$('#foo').html('remove');
		x$('#foo').html('before', '<p>some warmup html</p>');
		x$('#foo').html('after',  '<p>more html!</p>');

	or

		x$('#foo').html('<p>sweet as honey</p>');
		x$('#foo').outer('<p>free as a bird</p>');
		x$('#foo').top('<b>top of the pops</b>');
		x$('#foo').bottom('<span>bottom of the barrel</span>');
		x$('#foo').before('<pre>first in line</pre>');
		x$('#foo').after('<marquee>better late than never</marquee>');
*/
    html: function(location, html) {
        clean(this);

        if (arguments.length == 0) {
            var i = [];
            this.each(function(el) {
                i.push(el.innerHTML);
            });
            return i;
        }
        if (arguments.length == 1 && arguments[0] != 'remove') {
            html = location;
            location = 'inner';
        }
        if (location != 'remove' && html && html.each !== undefined) {
            if (location == 'inner') {
                var d = document.createElement('p');
                html.each(function(el) {
                    d.appendChild(el);
                });
                this.each(function(el) {
                    el.innerHTML = d.innerHTML;
                });
            } else {
                var that = this;
                html.each(function(el){
                    that.html(location, el);
                });
            }
            return this;
        }
        return this.each(function(el) {
            var parent, 
                list, 
                len, 
                i = 0;
            if (location == "inner") { // .html
                if (typeof html == string || typeof html == "number") {
                    el.innerHTML = html;
                    list = el.getElementsByTagName('SCRIPT');
                    len = list.length;
                    for (; i < len; i++) {
                        eval(list[i].text);
                    }
                } else {
                    el.innerHTML = '';
                    el.appendChild(html);
                }
            } else {
              if (location == 'remove') {
                el.parentNode.removeChild(el);
              } else {
                var elArray = ['outer', 'top', 'bottom'],
                    wrappedE = wrapHelper(html, (elArray.indexOf(location) > -1 ? el : el.parentNode )),
                    children = wrappedE.childNodes;
                if (location == "outer") { // .replaceWith
                  el.parentNode.replaceChild(wrappedE, el);
                } else if (location == "top") { // .prependTo
                    el.insertBefore(wrappedE, el.firstChild);
                } else if (location == "bottom") { // .appendTo
                    el.insertBefore(wrappedE, null);
                } else if (location == "before") { // .insertBefore
                    el.parentNode.insertBefore(wrappedE, el);
                } else if (location == "after") { // .insertAfter
                    el.parentNode.insertBefore(wrappedE, el.nextSibling);
                }
                var parent = wrappedE.parentNode;
                while(children.length) {
                  parent.insertBefore(children[0], wrappedE);
                }
                parent.removeChild(wrappedE);
              }
            }
        });
    },

/**
	attr
	----

	Gets or sets attributes on elements. If getting, returns an array of attributes matching the xui element collection's indices.

	### syntax ###

		x$( window ).attr( attribute, value );

	### arguments ###

	- attribute `String` is the name of HTML attribute to get or set.
	- value `Varies` is the value to set the attribute to. Do not use to get the value of attribute _(optional)_.

	### example ###

	To get an attribute value, simply don't provide the optional second parameter:

		x$('.someClass').attr('class');

	To set an attribute, use both parameters:

		x$('.someClass').attr('disabled', 'disabled');
*/
    attr: function(attribute, val) {
        if (arguments.length == 2) {
            return this.each(function(el) {
                if (el.tagName && el.tagName.toLowerCase() == 'input' && attribute == 'value') el.value = val;
                else if (el.setAttribute) {
                  if (attribute == 'checked' && (val == '' || val == false || typeof val == "undefined")) el.removeAttribute(attribute);
                  else el.setAttribute(attribute, val);
                }
            });
        } else {
            var attrs = [];
            this.each(function(el) {
                if (el.tagName && el.tagName.toLowerCase() == 'input' && attribute == 'value') attrs.push(el.value);
                else if (el.getAttribute && el.getAttribute(attribute)) {
                    attrs.push(el.getAttribute(attribute));
                }
            });
            return attrs;
        }
    }
});
"inner outer top bottom remove before after".split(' ').forEach(function (method) {
  xui.fn[method] = function(where) { return function (html) { return this.html(where, html); }; }(method);
});
// private method for finding a dom element
function getTag(el) {
    return (el.firstChild === null) ? {'UL':'LI','DL':'DT','TR':'TD'}[el.tagName] || el.tagName : el.firstChild.tagName;
}

function wrapHelper(html, el) {
  if (typeof html == string) return wrap(html, getTag(el));
  else { var e = document.createElement('div'); e.appendChild(html); return e; }
}

// private method
// Wraps the HTML in a TAG, Tag is optional
// If the html starts with a Tag, it will wrap the context in that tag.
function wrap(xhtml, tag) {
  var e = document.createElement('div');
  e.innerHTML = xhtml;
  return e;
}

/*
* Removes all erronious nodes from the DOM.
* 
*/
function clean(collection) {
    var ns = /\S/;
    collection.each(function(el) {
        var d = el,
            n = d.firstChild,
            ni = -1,
            nx;
        while (n) {
            nx = n.nextSibling;
            if (n.nodeType == 3 && !ns.test(n.nodeValue)) {
                d.removeChild(n);
            } else {
                n.nodeIndex = ++ni; // FIXME not sure what this is for, and causes IE to bomb (the setter) - @rem
            }
            n = nx;
        }
    });
}
/**
	Event
	=====

	A good old fashioned events with new skool handling. Shortcuts exist for:

	- click
	- load
	- touchstart
	- touchmove
	- touchend
	- touchcancel
	- gesturestart
	- gesturechange
	- gestureend
	- orientationchange
	
*/
xui.events = {}; var cache = {};
xui.extend({

/**
	on
	--

	Registers a callback function to a DOM event on the element collection.

	### syntax ###

		x$( 'button' ).on( type, fn );

	or

		x$( 'button' ).click( fn );

	### arguments ###

	- type `String` is the event to subscribe (e.g. _load_, _click_, _touchstart_, etc).
	- fn `Function` is a callback function to execute when the event is fired.

	### example ###

		x$( 'button' ).on( 'click', function(e) {
		    alert('hey that tickles!');
		});

	or

		x$(window).load(function(e) {
		  x$('.save').touchstart( function(evt) { alert('tee hee!'); }).css(background:'grey');
		});
*/
    on: function(type, fn, details) {
        return this.each(function (el) {
            if (xui.events[type]) {
                var id = _getEventID(el), 
                    responders = _getRespondersForEvent(id, type);
                
                details = details || {};
                details.handler = function (event, data) {
                    xui.fn.fire.call(xui(this), type, data);
                };
                
                // trigger the initialiser - only happens the first time around
                if (!responders.length) {
                    xui.events[type].call(el, details);
                }
            } 
            el.addEventListener(type, _createResponder(el, type, fn), false);
        });
    },

/**
	un
	--

	Unregisters a specific callback, or if no specific callback is passed in, 
	unregisters all event callbacks of a specific type.

	### syntax ###

	Unregister the given function, for the given type, on all button elements:

		x$( 'button' ).un( type, fn );

	Unregisters all callbacks of the given type, on all button elements:

		x$( 'button' ).un( type );

	### arguments ###

	- type `String` is the event to unsubscribe (e.g. _load_, _click_, _touchstart_, etc).
	- fn `Function` is the callback function to unsubscribe _(optional)_.

	### example ###

		// First, create a click event that display an alert message
		x$('button').on('click', function() {
		    alert('hi!');
		});
		
		// Now unsubscribe all functions that response to click on all button elements
		x$('button').un('click');

	or

		var greeting = function() { alert('yo!'); };
		
		x$('button').on('click', greeting);
		x$('button').on('click', function() {
		    alert('hi!');
		});
		
		// When any button is clicked, the 'hi!' message will fire, but not the 'yo!' message.
		x$('button').un('click', greeting);
*/
    un: function(type, fn) {
        return this.each(function (el) {
            var id = _getEventID(el), responders = _getRespondersForEvent(id, type), i = responders.length;

            while (i--) {
                if (fn === undefined || fn.guid === responders[i].guid) {
                    el.removeEventListener(type, responders[i], false);
                    removex(cache[id][type], i, 1);
                }
            }

            if (cache[id][type].length === 0) delete cache[id][type];
            for (var t in cache[id]) {
                return;
            }
            delete cache[id];
        });
    },

/**
	fire
	----

	Triggers a specific event on the xui collection.

	### syntax ###

		x$( selector ).fire( type, data );

	### arguments ###

	- type `String` is the event to fire (e.g. _load_, _click_, _touchstart_, etc).
	- data `Object` is a JSON object to use as the event's `data` property.

	### example ###

		x$('button#reset').fire('click', { died:true });
		
		x$('.target').fire('touchstart');
*/
    fire: function (type, data) {
        return this.each(function (el) {
            if (el == document && !el.dispatchEvent)
                el = document.documentElement;

            var event = document.createEvent('HTMLEvents');
            event.initEvent(type, true, true);
            event.data = data || {};
            event.eventName = type;
          
            el.dispatchEvent(event);
  	    });
  	}
});

"click load submit touchstart touchmove touchend touchcancel gesturestart gesturechange gestureend orientationchange".split(' ').forEach(function (event) {
  xui.fn[event] = function(action) { return function (fn) { return fn ? this.on(action, fn) : this.fire(action); }; }(event);
});

// patched orientation support - Andriod 1 doesn't have native onorientationchange events
xui(window).on('load', function() {
    if (!('onorientationchange' in document.body)) {
      (function (w, h) {
        xui(window).on('resize', function () {
          var portraitSwitch = (window.innerWidth < w && window.innerHeight > h) && (window.innerWidth < window.innerHeight),
              landscapeSwitch = (window.innerWidth > w && window.innerHeight < h) && (window.innerWidth > window.innerHeight);
          if (portraitSwitch || landscapeSwitch) {
            window.orientation = portraitSwitch ? 0 : 90; // what about -90? Some support is better than none
            xui('body').fire('orientationchange'); // will this bubble up?
            w = window.innerWidth;
            h = window.innerHeight;
          }
        });
      })(window.innerWidth, window.innerHeight);
    }
});

// this doesn't belong on the prototype, it belongs as a property on the xui object
xui.touch = (function () {
  try{
    return !!(document.createEvent("TouchEvent").initTouchEvent)
  } catch(e) {
    return false;
  };
})();

/**
	ready
	----

  Event handler for when the DOM is ready. Thank you [domready](http://www.github.com/ded/domready)!

	### syntax ###

		x$.ready(handler);

	### arguments ###

	- handler `Function` event handler to be attached to the "dom is ready" event.

	### example ###

    x$.ready(function() {
      alert('mah doms are ready');
    });

    xui.ready(function() {
      console.log('ready, set, go!');
    });
*/
xui.ready = function(handler) {
  domReady(handler);
}

// lifted from Prototype's (big P) event model
function _getEventID(element) {
    if (element._xuiEventID) return element._xuiEventID;
    return element._xuiEventID = ++_getEventID.id;
}

_getEventID.id = 1;

function _getRespondersForEvent(id, eventName) {
    var c = cache[id] = cache[id] || {};
    return c[eventName] = c[eventName] || [];
}

function _createResponder(element, eventName, handler) {
    var id = _getEventID(element), r = _getRespondersForEvent(id, eventName);

    var responder = function(event) {
        if (handler.call(element, event) === false) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    
    responder.guid = handler.guid = handler.guid || ++_getEventID.id;
    responder.handler = handler;
    r.push(responder);
    return responder;
}
/**
	Fx
	==

	Animations, transforms, and transitions for getting the most out of hardware accelerated CSS.

*/

xui.extend({

/**
	Tween
	-----

	Transforms a CSS property's value.

	### syntax ###

		x$( selector ).tween( properties, callback );

	### arguments ###

	- properties `Object` or `Array` of CSS properties to tween.
	    - `Object` is a JSON object that defines the CSS properties.
	    - `Array` is a `Object` set that is tweened sequentially.
	- callback `Function` to be called when the animation is complete. _(optional)_.

	### properties ###

	A property can be any CSS style, referenced by the JavaScript notation.

	A property can also be an option from [emile.js](https://github.com/madrobby/emile):

	- duration `Number` of the animation in milliseconds.
	- after `Function` is called after the animation is finished.
	- easing `Function` allows for the overriding of the built-in animation function.

			// Receives one argument `pos` that indicates position
			// in time between animation's start and end.
			function(pos) {
			    // return the new position
			    return (-Math.cos(pos * Math.PI) / 2) + 0.5;
			}

	### example ###

		// one JSON object
		x$('#box').tween({ left:'100px', backgroundColor:'blue' });
		x$('#box').tween({ left:'100px', backgroundColor:'blue' }, function() {
		    alert('done!');
		});
		
		// array of two JSON objects
		x$('#box').tween([{left:'100px', backgroundColor:'green', duration:.2 }, { right:'100px' }]); 
*/
	tween: function( props, callback ) {

    // creates an options obj for emile
    var emileOpts = function(o) {
      var options = {};
      "duration after easing".split(' ').forEach( function(p) {
        if (props[p]) {
            options[p] = props[p];
            delete props[p];
        }
      });
      return options;
    }

    // serialize the properties into a string for emile
    var serialize = function(props) {
      var serialisedProps = [], key;
      if (typeof props != string) {
        for (key in props) {
          serialisedProps.push(cssstyle(key) + ':' + props[key]);
        }
        serialisedProps = serialisedProps.join(';');
      } else {
        serialisedProps = props;
      }
      return serialisedProps;
    };

    // queued animations
    /* wtf is this?
		if (props instanceof Array) {
		    // animate each passing the next to the last callback to enqueue
		    props.forEach(function(a){
		      
		    });
		}
    */
    // this branch means we're dealing with a single tween
    var opts = emileOpts(props);
    var prop = serialize(props);
		
		return this.each(function(e){
			emile(e, prop, opts, callback);
		});
	}
});
/**
	Style
	=====

	Everything related to appearance. Usually, this is CSS.

*/
function hasClass(el, className) {
    return getClassRegEx(className).test(el.className);
}

// Via jQuery - used to avoid el.className = ' foo';
// Used for trimming whitespace
var rtrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;

function trim(text) {
  return (text || "").replace( rtrim, "" );
}

xui.extend({
/**
	setStyle
	--------

	Sets the value of a single CSS property.

	### syntax ###

		x$( selector ).setStyle( property, value );

	### arguments ###

	- property `String` is the name of the property to modify.
	- value `String` is the new value of the property.

	### example ###

		x$('.flash').setStyle('color', '#000');
		x$('.button').setStyle('backgroundColor', '#EFEFEF');
*/
    setStyle: function(prop, val) {
        prop = domstyle(prop);
        return this.each(function(el) {
            el.style[prop] = val;
        });
    },

/**
	getStyle
	--------

	Returns the value of a single CSS property. Can also invoke a callback to perform more specific processing tasks related to the property value.
	Please note that the return type is always an Array of strings. Each string corresponds to the CSS property value for the element with the same index in the xui collection.

	### syntax ###

		x$( selector ).getStyle( property, callback );

	### arguments ###

	- property `String` is the name of the CSS property to get.
	- callback `Function` is called on each element in the collection and passed the property _(optional)_.

	### example ###
        <ul id="nav">
            <li class="trunk" style="font-size:12px;background-color:blue;">hi</li>
            <li style="font-size:14px;">there</li>
        </ul>
        
		x$('ul#nav li.trunk').getStyle('font-size'); // returns ['12px']
		x$('ul#nav li.trunk').getStyle('fontSize'); // returns ['12px']
		x$('ul#nav li').getStyle('font-size'); // returns ['12px', '14px']
		
		x$('ul#nav li.trunk').getStyle('backgroundColor', function(prop) {
		    alert(prop); // alerts 'blue' 
		});
*/
    getStyle: function(prop, callback) {
        // shortcut getComputedStyle function
        var s = function(el, p) {
            // this *can* be written to be smaller - see below, but in fact it doesn't compress in gzip as well, the commented
            // out version actually *adds* 2 bytes.
            // return document.defaultView.getComputedStyle(el, "").getPropertyValue(p.replace(/([A-Z])/g, "-$1").toLowerCase());
            return document.defaultView.getComputedStyle(el, "").getPropertyValue(cssstyle(p));
        }
        if (callback === undefined) {
        	var styles = [];
          this.each(function(el) {styles.push(s(el, prop))});
          return styles;
        } else return this.each(function(el) { callback(s(el, prop)); });
    },

/**
	addClass
	--------

	Adds a class to all of the elements in the collection.

	### syntax ###

		x$( selector ).addClass( className );

	### arguments ###

	- className `String` is the name of the CSS class to add.

	### example ###

		x$('.foo').addClass('awesome');
*/
    addClass: function(className) {
        var cs = className.split(' ');
        return this.each(function(el) {
            cs.forEach(function(clazz) {
              if (hasClass(el, clazz) === false) {
                el.className = trim(el.className + ' ' + clazz);
              }
            });
        });
    },

/**
	hasClass
	--------

	Checks if the class is on _all_ elements in the xui collection.

	### syntax ###

		x$( selector ).hasClass( className, fn );

	### arguments ###

	- className `String` is the name of the CSS class to find.
	- fn `Function` is a called for each element found and passed the element _(optional)_.

			// `element` is the HTMLElement that has the class
			function(element) {
			    console.log(element);
			}

	### example ###
        <div id="foo" class="foo awesome"></div>
        <div class="foo awesome"></div>
        <div class="foo"></div>
        
		// returns true
		x$('#foo').hasClass('awesome');
		
		// returns false (not all elements with class 'foo' have class 'awesome'),
		// but the callback gets invoked with the elements that did match the 'awesome' class
		x$('.foo').hasClass('awesome', function(element) {
		    console.log('Hey, I found: ' + element + ' with class "awesome"');
		});
		
		// returns true (all DIV elements have the 'foo' class)
		x$('div').hasClass('foo');
*/
    hasClass: function(className, callback) {
        var self = this,
            cs = className.split(' ');
        return this.length && (function() {
                var hasIt = true;
                self.each(function(el) {
                  cs.forEach(function(clazz) {
                    if (hasClass(el, clazz)) {
                        if (callback) callback(el);
                    } else hasIt = false;
                  });
                });
                return hasIt;
            })();
    },

/**
	removeClass
	-----------

	Removes the specified class from all elements in the collection. If no class is specified, removes all classes from the collection.

	### syntax ###

		x$( selector ).removeClass( className );

	### arguments ###

	- className `String` is the name of the CSS class to remove. If not specified, then removes all classes from the matched elements. _(optional)_

	### example ###

		x$('.foo').removeClass('awesome');
*/
    removeClass: function(className) {
        if (className === undefined) this.each(function(el) { el.className = ''; });
        else {
          var cs = className.split(' ');
          this.each(function(el) {
            cs.forEach(function(clazz) {
              el.className = trim(el.className.replace(getClassRegEx(clazz), '$1'));
            });
          });
        }
        return this;
    },

/**
	toggleClass
	-----------

	Removes the specified class if it exists on the elements in the xui collection, otherwise adds it. 

	### syntax ###

		x$( selector ).toggleClass( className );

	### arguments ###

	- className `String` is the name of the CSS class to toggle.

	### example ###
        <div class="foo awesome"></div>
        
		x$('.foo').toggleClass('awesome'); // div above loses its awesome class.
*/
    toggleClass: function(className) {
        var cs = className.split(' ');
        return this.each(function(el) {
            cs.forEach(function(clazz) {
              if (hasClass(el, clazz)) el.className = trim(el.className.replace(getClassRegEx(clazz), '$1'));
              else el.className = trim(el.className + ' ' + clazz);
            });
        });
    },
    
/**
	css
	---

	Set multiple CSS properties at once.

	### syntax ###

		x$( selector ).css( properties );

	### arguments ###

	- properties `Object` is a JSON object that defines the property name/value pairs to set.

	### example ###

		x$('.foo').css({ backgroundColor:'blue', color:'white', border:'2px solid red' });
*/
    css: function(o) {
        for (var prop in o) {
            this.setStyle(prop, o[prop]);
        }
        return this;
    }
});

// RS: now that I've moved these out, they'll compress better, however, do these variables
// need to be instance based - if it's regarding the DOM, I'm guessing it's better they're
// global within the scope of xui

// -- private methods -- //
var reClassNameCache = {},
    getClassRegEx = function(className) {
        var re = reClassNameCache[className];
        if (!re) {
            // Preserve any leading whitespace in the match, to be used when removing a class
            re = new RegExp('(^|\\s+)' + className + '(?:\\s+|$)');
            reClassNameCache[className] = re;
        }
        return re;
    };
/**
	XHR
	===

	Everything related to remote network connections.

 */
xui.extend({	
/**
	xhr
	---

	The classic `XMLHttpRequest` sometimes also known as the Greek hero: _Ajax_. Not to be confused with _AJAX_ the cleaning agent.

	### detail ###

	This method has a few new tricks.

	It is always invoked on an element collection and uses the behaviour of `html`.

	If there is no callback, then the `responseText` will be inserted into the elements in the collection.

	### syntax ###

		x$( selector ).xhr( location, url, options )

	or accept a url with a default behavior of inner:

		x$( selector ).xhr( url, options );

	or accept a url with a callback:
	
		x$( selector ).xhr( url, fn );

	### arguments ###

	- location `String` is the location to insert the `responseText`. See `html` for values.
	- url `String` is where to send the request.
	- fn `Function` is called on status 200 (i.e. success callback).
	- options `Object` is a JSON object with one or more of the following:
		- method `String` can be _get_, _put_, _delete_, _post_. Default is _get_.
		- async `Boolean` enables an asynchronous request. Defaults to _false_.
		- data `String` is a url encoded string of parameters to send.
                - error `Function` is called on error or status that is not 200. (i.e. failure callback).
		- callback `Function` is called on status 200 (i.e. success callback).
    - headers `Object` is a JSON object with key:value pairs that get set in the request's header set.

	### response ###

	- The response is available to the callback function as `this`.
	- The response is not passed into the callback.
	- `this.reponseText` will have the resulting data from the file.

	### example ###

		x$('#status').xhr('inner', '/status.html');
		x$('#status').xhr('outer', '/status.html');
		x$('#status').xhr('top',   '/status.html');
		x$('#status').xhr('bottom','/status.html');
		x$('#status').xhr('before','/status.html');
		x$('#status').xhr('after', '/status.html');

	or

		// same as using 'inner'
		x$('#status').xhr('/status.html');

		// define a callback, enable async execution and add a request header
		x$('#left-panel').xhr('/panel', {
		    async: true,
		    callback: function() {
		        alert("The response is " + this.responseText);
		    },
        headers:{
            'Mobile':'true'
        }
		});

		// define a callback with the shorthand syntax
		x$('#left-panel').xhr('/panel', function() {
		    alert("The response is " + this.responseText);
		});
*/
    xhr:function(location, url, options) {

      // this is to keep support for the old syntax (easy as that)
		if (!/^(inner|outer|top|bottom|before|after)$/.test(location)) {
            options = url;
            url = location;
            location = 'inner';
        }

        var o = options ? options : {};
        
        if (typeof options == "function") {
            // FIXME kill the console logging
            // console.log('we been passed a func ' + options);
            // console.log(this);
            o = {};
            o.callback = options;
        };
        
        var that   = this,
            req    = new XMLHttpRequest(),
            method = o.method || 'get',
            async  = (typeof o.async != 'undefined'?o.async:true),
            params = o.data || null,
            key;

        req.queryString = params;
        req.open(method, url, async);

        // Set "X-Requested-With" header
        req.setRequestHeader('X-Requested-With','XMLHttpRequest');

        if (method.toLowerCase() == 'post') req.setRequestHeader('Content-Type','application/x-www-form-urlencoded');

        for (key in o.headers) {
            if (o.headers.hasOwnProperty(key)) {
              req.setRequestHeader(key, o.headers[key]);
            }
        }

        req.handleResp = (o.callback != null) ? o.callback : function() { that.html(location, req.responseText); };
        req.handleError = (o.error && typeof o.error == 'function') ? o.error : function () {};
        function hdl(){
            if(req.readyState==4) {
                delete(that.xmlHttpRequest);
                if((/^[20]/).test(req.status)) req.handleResp();
                if((/^[45]/).test(req.status)) req.handleError();
            }
        }
        if(async) {
            req.onreadystatechange = hdl;
            this.xmlHttpRequest = req;
        }
        req.send(params);
        if(!async) hdl();

        return this;
    }
});
// emile.js (c) 2009 Thomas Fuchs
// Licensed under the terms of the MIT license.

(function(emile, container){
  var parseEl = document.createElement('div'),
    props = ('backgroundColor borderBottomColor borderBottomWidth borderLeftColor borderLeftWidth '+
    'borderRightColor borderRightWidth borderSpacing borderTopColor borderTopWidth bottom color fontSize '+
    'fontWeight height left letterSpacing lineHeight marginBottom marginLeft marginRight marginTop maxHeight '+
    'maxWidth minHeight minWidth opacity outlineColor outlineOffset outlineWidth paddingBottom paddingLeft '+
    'paddingRight paddingTop right textIndent top width wordSpacing zIndex').split(' ');

  function interpolate(source,target,pos){ return (source+(target-source)*pos).toFixed(3); }
  function s(str, p, c){ return str.substr(p,c||1); }
  function color(source,target,pos){
    var i = 2, j, c, tmp, v = [], r = [];
    while(j=3,c=arguments[i-1],i--)
      if(s(c,0)=='r') { c = c.match(/\d+/g); while(j--) v.push(~~c[j]); } else {
        if(c.length==4) c='#'+s(c,1)+s(c,1)+s(c,2)+s(c,2)+s(c,3)+s(c,3);
        while(j--) v.push(parseInt(s(c,1+j*2,2), 16)); }
    while(j--) { tmp = ~~(v[j+3]+(v[j]-v[j+3])*pos); r.push(tmp<0?0:tmp>255?255:tmp); }
    return 'rgb('+r.join(',')+')';
  }
  
  function parse(prop){
    var p = parseFloat(prop), q = prop.replace(/^[\-\d\.]+/,'');
    return isNaN(p) ? { v: q, f: color, u: ''} : { v: p, f: interpolate, u: q };
  }
  
  function normalize(style){
    var css, rules = {}, i = props.length, v;
    parseEl.innerHTML = '<div style="'+style+'"></div>';
    css = parseEl.childNodes[0].style;
    while(i--) if(v = css[props[i]]) rules[props[i]] = parse(v);
    return rules;
  }  
  
  container[emile] = function(el, style, opts, after){
    el = typeof el == 'string' ? document.getElementById(el) : el;
    opts = opts || {};
    var target = normalize(style), comp = el.currentStyle ? el.currentStyle : getComputedStyle(el, null),
      prop, current = {}, start = +new Date, dur = opts.duration||200, finish = start+dur, interval,
      easing = opts.easing || function(pos){ return (-Math.cos(pos*Math.PI)/2) + 0.5; };
    for(prop in target) current[prop] = parse(comp[prop]);
    interval = setInterval(function(){
      var time = +new Date, pos = time>finish ? 1 : (time-start)/dur;
      for(prop in target)
        el.style[prop] = target[prop].f(current[prop].v,target[prop].v,easing(pos)) + target[prop].u;
      if(time>finish) { clearInterval(interval); opts.after && opts.after(); after && setTimeout(after,1); }
    },10);
  }
})('emile', this);
!function (context, doc) {
  var fns = [], ol, fn, f = false,
      testEl = doc.documentElement,
      hack = testEl.doScroll,
      domContentLoaded = 'DOMContentLoaded',
      addEventListener = 'addEventListener',
      onreadystatechange = 'onreadystatechange',
      loaded = /^loade|c/.test(doc.readyState);

  function flush(i) {
    loaded = 1;
    while (i = fns.shift()) { i() }
  }
  doc[addEventListener] && doc[addEventListener](domContentLoaded, fn = function () {
    doc.removeEventListener(domContentLoaded, fn, f);
    flush();
  }, f);


  hack && doc.attachEvent(onreadystatechange, (ol = function () {
    if (/^c/.test(doc.readyState)) {
      doc.detachEvent(onreadystatechange, ol);
      flush();
    }
  }));

  context['domReady'] = hack ?
    function (fn) {
      self != top ?
        loaded ? fn() : fns.push(fn) :
        function () {
          try {
            testEl.doScroll('left');
          } catch (e) {
            return setTimeout(function() { context['domReady'](fn) }, 50);
          }
          fn();
        }()
    } :
    function (fn) {
      loaded ? fn() : fns.push(fn);
    };

}(this, document);
})();
;/*!
 * iScroll v4.2.5 ~ Copyright (c) 2012 Matteo Spinelli, http://cubiq.org
 * Released under MIT license, http://cubiq.org/license
 */
(function(window, doc){
var m = Math,
	dummyStyle = doc.createElement('div').style,
	vendor = (function () {
		var vendors = 't,webkitT,MozT,msT,OT'.split(','),
			t,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			t = vendors[i] + 'ransform';
			if ( t in dummyStyle ) {
				return vendors[i].substr(0, vendors[i].length - 1);
			}
		}

		return false;
	})(),
	cssVendor = vendor ? '-' + vendor.toLowerCase() + '-' : '',

	// Style properties
	transform = prefixStyle('transform'),
	transitionProperty = prefixStyle('transitionProperty'),
	transitionDuration = prefixStyle('transitionDuration'),
	transformOrigin = prefixStyle('transformOrigin'),
	transitionTimingFunction = prefixStyle('transitionTimingFunction'),
	transitionDelay = prefixStyle('transitionDelay'),

    // Browser capabilities
	isAndroid = (/android/gi).test(navigator.appVersion),
	isIDevice = (/iphone|ipad/gi).test(navigator.appVersion),
	isTouchPad = (/hp-tablet/gi).test(navigator.appVersion),

    has3d = prefixStyle('perspective') in dummyStyle,
    hasTouch = 'ontouchstart' in window && !isTouchPad,
    hasTransform = vendor !== false,
    hasTransitionEnd = prefixStyle('transition') in dummyStyle,

	RESIZE_EV = 'onorientationchange' in window ? 'orientationchange' : 'resize',
	START_EV = hasTouch ? 'touchstart' : 'mousedown',
	MOVE_EV = hasTouch ? 'touchmove' : 'mousemove',
	END_EV = hasTouch ? 'touchend' : 'mouseup',
	CANCEL_EV = hasTouch ? 'touchcancel' : 'mouseup',
	TRNEND_EV = (function () {
		if ( vendor === false ) return false;

		var transitionEnd = {
				''			: 'transitionend',
				'webkit'	: 'webkitTransitionEnd',
				'Moz'		: 'transitionend',
				'O'			: 'otransitionend',
				'ms'		: 'MSTransitionEnd'
			};

		return transitionEnd[vendor];
	})(),

	nextFrame = (function() {
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) { return setTimeout(callback, 1); };
	})(),
	cancelFrame = (function () {
		return window.cancelRequestAnimationFrame ||
			window.webkitCancelAnimationFrame ||
			window.webkitCancelRequestAnimationFrame ||
			window.mozCancelRequestAnimationFrame ||
			window.oCancelRequestAnimationFrame ||
			window.msCancelRequestAnimationFrame ||
			clearTimeout;
	})(),

	// Helpers
	translateZ = has3d ? ' translateZ(0)' : '',

	// Constructor
	iScroll = function (el, options) {
		var that = this,
			i;

		that.wrapper = typeof el == 'object' ? el : doc.getElementById(el);
		that.wrapper.style.overflow = 'hidden';
		that.scroller = that.wrapper.children[0];

		// Default options
		that.options = {
			hScroll: true,
			vScroll: true,
			x: 0,
			y: 0,
			bounce: true,
			bounceLock: false,
			momentum: true,
			lockDirection: true,
			useTransform: true,
			useTransition: false,
			topOffset: 0,
			checkDOMChanges: false,		// Experimental
			handleClick: true,

			// Scrollbar
			hScrollbar: true,
			vScrollbar: true,
			fixedScrollbar: isAndroid,
			hideScrollbar: isIDevice,
			fadeScrollbar: isIDevice && has3d,
			scrollbarClass: '',

			// Zoom
			zoom: false,
			zoomMin: 1,
			zoomMax: 4,
			doubleTapZoom: 2,
			wheelAction: 'scroll',

			// Snap
			snap: false,
			snapThreshold: 1,

			// Events
			onRefresh: null,
			onBeforeScrollStart: function (e) { e.preventDefault(); },
			onScrollStart: null,
			onBeforeScrollMove: null,
			onScrollMove: null,
			onBeforeScrollEnd: null,
			onScrollEnd: null,
			onTouchEnd: null,
			onDestroy: null,
			onZoomStart: null,
			onZoom: null,
			onZoomEnd: null
		};

		// User defined options
		for (i in options) that.options[i] = options[i];
		
		// Set starting position
		that.x = that.options.x;
		that.y = that.options.y;

		// Normalize options
		that.options.useTransform = hasTransform && that.options.useTransform;
		that.options.hScrollbar = that.options.hScroll && that.options.hScrollbar;
		that.options.vScrollbar = that.options.vScroll && that.options.vScrollbar;
		that.options.zoom = that.options.useTransform && that.options.zoom;
		that.options.useTransition = hasTransitionEnd && that.options.useTransition;

		// Helpers FIX ANDROID BUG!
		// translate3d and scale doesn't work together!
		// Ignoring 3d ONLY WHEN YOU SET that.options.zoom
		if ( that.options.zoom && isAndroid ){
			translateZ = '';
		}
		
		// Set some default styles
		that.scroller.style[transitionProperty] = that.options.useTransform ? cssVendor + 'transform' : 'top left';
		that.scroller.style[transitionDuration] = '0';
		that.scroller.style[transformOrigin] = '0 0';
		if (that.options.useTransition) that.scroller.style[transitionTimingFunction] = 'cubic-bezier(0.33,0.66,0.66,1)';
		
		if (that.options.useTransform) that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px)' + translateZ;
		else that.scroller.style.cssText += ';position:absolute;top:' + that.y + 'px;left:' + that.x + 'px';

		if (that.options.useTransition) that.options.fixedScrollbar = true;

		that.refresh();

		that._bind(RESIZE_EV, window);
		that._bind(START_EV);
		if (!hasTouch) {
			if (that.options.wheelAction != 'none') {
				that._bind('DOMMouseScroll');
				that._bind('mousewheel');
			}
		}

		if (that.options.checkDOMChanges) that.checkDOMTime = setInterval(function () {
			that._checkDOMChanges();
		}, 500);
	};

// Prototype
iScroll.prototype = {
	enabled: true,
	x: 0,
	y: 0,
	steps: [],
	scale: 1,
	currPageX: 0, currPageY: 0,
	pagesX: [], pagesY: [],
	aniTime: null,
	wheelZoomCount: 0,
	
	handleEvent: function (e) {
		var that = this;
		switch(e.type) {
			case START_EV:
				if (!hasTouch && e.button !== 0) return;
				that._start(e);
				break;
			case MOVE_EV: that._move(e); break;
			case END_EV:
			case CANCEL_EV: that._end(e); break;
			case RESIZE_EV: that._resize(); break;
			case 'DOMMouseScroll': case 'mousewheel': that._wheel(e); break;
			case TRNEND_EV: that._transitionEnd(e); break;
		}
	},
	
	_checkDOMChanges: function () {
		if (this.moved || this.zoomed || this.animating ||
			(this.scrollerW == this.scroller.offsetWidth * this.scale && this.scrollerH == this.scroller.offsetHeight * this.scale)) return;

		this.refresh();
	},
	
	_scrollbar: function (dir) {
		var that = this,
			bar;

		if (!that[dir + 'Scrollbar']) {
			if (that[dir + 'ScrollbarWrapper']) {
				if (hasTransform) that[dir + 'ScrollbarIndicator'].style[transform] = '';
				that[dir + 'ScrollbarWrapper'].parentNode.removeChild(that[dir + 'ScrollbarWrapper']);
				that[dir + 'ScrollbarWrapper'] = null;
				that[dir + 'ScrollbarIndicator'] = null;
			}

			return;
		}

		if (!that[dir + 'ScrollbarWrapper']) {
			// Create the scrollbar wrapper
			bar = doc.createElement('div');

			if (that.options.scrollbarClass) bar.className = that.options.scrollbarClass + dir.toUpperCase();
			else bar.style.cssText = 'position:absolute;z-index:100;' + (dir == 'h' ? 'height:7px;bottom:1px;left:2px;right:' + (that.vScrollbar ? '7' : '2') + 'px' : 'width:7px;bottom:' + (that.hScrollbar ? '7' : '2') + 'px;top:2px;right:1px');

			bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:opacity;' + cssVendor + 'transition-duration:' + (that.options.fadeScrollbar ? '350ms' : '0') + ';overflow:hidden;opacity:' + (that.options.hideScrollbar ? '0' : '1');

			that.wrapper.appendChild(bar);
			that[dir + 'ScrollbarWrapper'] = bar;

			// Create the scrollbar indicator
			bar = doc.createElement('div');
			if (!that.options.scrollbarClass) {
				bar.style.cssText = 'position:absolute;z-index:100;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);' + cssVendor + 'background-clip:padding-box;' + cssVendor + 'box-sizing:border-box;' + (dir == 'h' ? 'height:100%' : 'width:100%') + ';' + cssVendor + 'border-radius:3px;border-radius:3px';
			}
			bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:' + cssVendor + 'transform;' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1);' + cssVendor + 'transition-duration:0;' + cssVendor + 'transform: translate(0,0)' + translateZ;
			if (that.options.useTransition) bar.style.cssText += ';' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1)';

			that[dir + 'ScrollbarWrapper'].appendChild(bar);
			that[dir + 'ScrollbarIndicator'] = bar;
		}

		if (dir == 'h') {
			that.hScrollbarSize = that.hScrollbarWrapper.clientWidth;
			that.hScrollbarIndicatorSize = m.max(m.round(that.hScrollbarSize * that.hScrollbarSize / that.scrollerW), 8);
			that.hScrollbarIndicator.style.width = that.hScrollbarIndicatorSize + 'px';
			that.hScrollbarMaxScroll = that.hScrollbarSize - that.hScrollbarIndicatorSize;
			that.hScrollbarProp = that.hScrollbarMaxScroll / that.maxScrollX;
		} else {
			that.vScrollbarSize = that.vScrollbarWrapper.clientHeight;
			that.vScrollbarIndicatorSize = m.max(m.round(that.vScrollbarSize * that.vScrollbarSize / that.scrollerH), 8);
			that.vScrollbarIndicator.style.height = that.vScrollbarIndicatorSize + 'px';
			that.vScrollbarMaxScroll = that.vScrollbarSize - that.vScrollbarIndicatorSize;
			that.vScrollbarProp = that.vScrollbarMaxScroll / that.maxScrollY;
		}

		// Reset position
		that._scrollbarPos(dir, true);
	},
	
	_resize: function () {
		var that = this;
		setTimeout(function () { that.refresh(); }, isAndroid ? 200 : 0);
	},
	
	_pos: function (x, y) {
		if (this.zoomed) return;

		x = this.hScroll ? x : 0;
		y = this.vScroll ? y : 0;

		if (this.options.useTransform) {
			this.scroller.style[transform] = 'translate(' + x + 'px,' + y + 'px) scale(' + this.scale + ')' + translateZ;
		} else {
			x = m.round(x);
			y = m.round(y);
			this.scroller.style.left = x + 'px';
			this.scroller.style.top = y + 'px';
		}

		this.x = x;
		this.y = y;

		this._scrollbarPos('h');
		this._scrollbarPos('v');
	},

	_scrollbarPos: function (dir, hidden) {
		var that = this,
			pos = dir == 'h' ? that.x : that.y,
			size;

		if (!that[dir + 'Scrollbar']) return;

		pos = that[dir + 'ScrollbarProp'] * pos;

		if (pos < 0) {
			if (!that.options.fixedScrollbar) {
				size = that[dir + 'ScrollbarIndicatorSize'] + m.round(pos * 3);
				if (size < 8) size = 8;
				that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
			}
			pos = 0;
		} else if (pos > that[dir + 'ScrollbarMaxScroll']) {
			if (!that.options.fixedScrollbar) {
				size = that[dir + 'ScrollbarIndicatorSize'] - m.round((pos - that[dir + 'ScrollbarMaxScroll']) * 3);
				if (size < 8) size = 8;
				that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
				pos = that[dir + 'ScrollbarMaxScroll'] + (that[dir + 'ScrollbarIndicatorSize'] - size);
			} else {
				pos = that[dir + 'ScrollbarMaxScroll'];
			}
		}

		that[dir + 'ScrollbarWrapper'].style[transitionDelay] = '0';
		that[dir + 'ScrollbarWrapper'].style.opacity = hidden && that.options.hideScrollbar ? '0' : '1';
		that[dir + 'ScrollbarIndicator'].style[transform] = 'translate(' + (dir == 'h' ? pos + 'px,0)' : '0,' + pos + 'px)') + translateZ;
	},
	
	_start: function (e) {
		var that = this,
			point = hasTouch ? e.touches[0] : e,
			matrix, x, y,
			c1, c2;

		if (!that.enabled) return;

		if (that.options.onBeforeScrollStart) that.options.onBeforeScrollStart.call(that, e);

		if (that.options.useTransition || that.options.zoom) that._transitionTime(0);

		that.moved = false;
		that.animating = false;
		that.zoomed = false;
		that.distX = 0;
		that.distY = 0;
		that.absDistX = 0;
		that.absDistY = 0;
		that.dirX = 0;
		that.dirY = 0;

		// Gesture start
		if (that.options.zoom && hasTouch && e.touches.length > 1) {
			c1 = m.abs(e.touches[0].pageX-e.touches[1].pageX);
			c2 = m.abs(e.touches[0].pageY-e.touches[1].pageY);
			that.touchesDistStart = m.sqrt(c1 * c1 + c2 * c2);

			that.originX = m.abs(e.touches[0].pageX + e.touches[1].pageX - that.wrapperOffsetLeft * 2) / 2 - that.x;
			that.originY = m.abs(e.touches[0].pageY + e.touches[1].pageY - that.wrapperOffsetTop * 2) / 2 - that.y;

			if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
		}

		if (that.options.momentum) {
			if (that.options.useTransform) {
				// Very lame general purpose alternative to CSSMatrix
				matrix = getComputedStyle(that.scroller, null)[transform].replace(/[^0-9\-.,]/g, '').split(',');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +getComputedStyle(that.scroller, null).left.replace(/[^0-9-]/g, '');
				y = +getComputedStyle(that.scroller, null).top.replace(/[^0-9-]/g, '');
			}
			
			if (x != that.x || y != that.y) {
				if (that.options.useTransition) that._unbind(TRNEND_EV);
				else cancelFrame(that.aniTime);
				that.steps = [];
				that._pos(x, y);
				if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);
			}
		}

		that.absStartX = that.x;	// Needed by snap threshold
		that.absStartY = that.y;

		that.startX = that.x;
		that.startY = that.y;
		that.pointX = point.pageX;
		that.pointY = point.pageY;

		that.startTime = e.timeStamp || Date.now();

		if (that.options.onScrollStart) that.options.onScrollStart.call(that, e);

		that._bind(MOVE_EV, window);
		that._bind(END_EV, window);
		that._bind(CANCEL_EV, window);
	},
	
	_move: function (e) {
		var that = this,
			point = hasTouch ? e.touches[0] : e,
			deltaX = point.pageX - that.pointX,
			deltaY = point.pageY - that.pointY,
			newX = that.x + deltaX,
			newY = that.y + deltaY,
			c1, c2, scale,
			timestamp = e.timeStamp || Date.now();

		if (that.options.onBeforeScrollMove) that.options.onBeforeScrollMove.call(that, e);

		// Zoom
		if (that.options.zoom && hasTouch && e.touches.length > 1) {
			c1 = m.abs(e.touches[0].pageX - e.touches[1].pageX);
			c2 = m.abs(e.touches[0].pageY - e.touches[1].pageY);
			that.touchesDist = m.sqrt(c1*c1+c2*c2);

			that.zoomed = true;

			scale = 1 / that.touchesDistStart * that.touchesDist * this.scale;

			if (scale < that.options.zoomMin) scale = 0.5 * that.options.zoomMin * Math.pow(2.0, scale / that.options.zoomMin);
			else if (scale > that.options.zoomMax) scale = 2.0 * that.options.zoomMax * Math.pow(0.5, that.options.zoomMax / scale);

			that.lastScale = scale / this.scale;

			newX = this.originX - this.originX * that.lastScale + this.x;
			newY = this.originY - this.originY * that.lastScale + this.y;

			this.scroller.style[transform] = 'translate(' + newX + 'px,' + newY + 'px) scale(' + scale + ')' + translateZ;

			if (that.options.onZoom) that.options.onZoom.call(that, e);
			return;
		}

		that.pointX = point.pageX;
		that.pointY = point.pageY;

		// Slow down if outside of the boundaries
		if (newX > 0 || newX < that.maxScrollX) {
			newX = that.options.bounce ? that.x + (deltaX / 2) : newX >= 0 || that.maxScrollX >= 0 ? 0 : that.maxScrollX;
		}
		if (newY > that.minScrollY || newY < that.maxScrollY) {
			newY = that.options.bounce ? that.y + (deltaY / 2) : newY >= that.minScrollY || that.maxScrollY >= 0 ? that.minScrollY : that.maxScrollY;
		}

		that.distX += deltaX;
		that.distY += deltaY;
		that.absDistX = m.abs(that.distX);
		that.absDistY = m.abs(that.distY);

		if (that.absDistX < 6 && that.absDistY < 6) {
			return;
		}

		// Lock direction
		if (that.options.lockDirection) {
			if (that.absDistX > that.absDistY + 5) {
				newY = that.y;
				deltaY = 0;
			} else if (that.absDistY > that.absDistX + 5) {
				newX = that.x;
				deltaX = 0;
			}
		}

		that.moved = true;
		that._pos(newX, newY);
		that.dirX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		that.dirY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if (timestamp - that.startTime > 300) {
			that.startTime = timestamp;
			that.startX = that.x;
			that.startY = that.y;
		}
		
		if (that.options.onScrollMove) that.options.onScrollMove.call(that, e);
	},
	
	_end: function (e) {
		if (hasTouch && e.touches.length !== 0) return;

		var that = this,
			point = hasTouch ? e.changedTouches[0] : e,
			target, ev,
			momentumX = { dist:0, time:0 },
			momentumY = { dist:0, time:0 },
			duration = (e.timeStamp || Date.now()) - that.startTime,
			newPosX = that.x,
			newPosY = that.y,
			distX, distY,
			newDuration,
			snap,
			scale;

		that._unbind(MOVE_EV, window);
		that._unbind(END_EV, window);
		that._unbind(CANCEL_EV, window);

		if (that.options.onBeforeScrollEnd) that.options.onBeforeScrollEnd.call(that, e);

		if (that.zoomed) {
			scale = that.scale * that.lastScale;
			scale = Math.max(that.options.zoomMin, scale);
			scale = Math.min(that.options.zoomMax, scale);
			that.lastScale = scale / that.scale;
			that.scale = scale;

			that.x = that.originX - that.originX * that.lastScale + that.x;
			that.y = that.originY - that.originY * that.lastScale + that.y;
			
			that.scroller.style[transitionDuration] = '200ms';
			that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + that.scale + ')' + translateZ;
			
			that.zoomed = false;
			that.refresh();

			if (that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
			return;
		}

		if (!that.moved) {
			if (hasTouch) {
				if (that.doubleTapTimer && that.options.zoom) {
					// Double tapped
					clearTimeout(that.doubleTapTimer);
					that.doubleTapTimer = null;
					if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
					that.zoom(that.pointX, that.pointY, that.scale == 1 ? that.options.doubleTapZoom : 1);
					if (that.options.onZoomEnd) {
						setTimeout(function() {
							that.options.onZoomEnd.call(that, e);
						}, 200); // 200 is default zoom duration
					}
				} else if (this.options.handleClick) {
					that.doubleTapTimer = setTimeout(function () {
						that.doubleTapTimer = null;

						// Find the last touched element
						target = point.target;
						while (target.nodeType != 1) target = target.parentNode;

						if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA') {
							ev = doc.createEvent('MouseEvents');
							ev.initMouseEvent('click', true, true, e.view, 1,
								point.screenX, point.screenY, point.clientX, point.clientY,
								e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
								0, null);
							ev._fake = true;
							target.dispatchEvent(ev);
						}
					}, that.options.zoom ? 250 : 0);
				}
			}

			that._resetPos(400);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		if (duration < 300 && that.options.momentum) {
			momentumX = newPosX ? that._momentum(newPosX - that.startX, duration, -that.x, that.scrollerW - that.wrapperW + that.x, that.options.bounce ? that.wrapperW : 0) : momentumX;
			momentumY = newPosY ? that._momentum(newPosY - that.startY, duration, -that.y, (that.maxScrollY < 0 ? that.scrollerH - that.wrapperH + that.y - that.minScrollY : 0), that.options.bounce ? that.wrapperH : 0) : momentumY;

			newPosX = that.x + momentumX.dist;
			newPosY = that.y + momentumY.dist;

			if ((that.x > 0 && newPosX > 0) || (that.x < that.maxScrollX && newPosX < that.maxScrollX)) momentumX = { dist:0, time:0 };
			if ((that.y > that.minScrollY && newPosY > that.minScrollY) || (that.y < that.maxScrollY && newPosY < that.maxScrollY)) momentumY = { dist:0, time:0 };
		}

		if (momentumX.dist || momentumY.dist) {
			newDuration = m.max(m.max(momentumX.time, momentumY.time), 10);

			// Do we need to snap?
			if (that.options.snap) {
				distX = newPosX - that.absStartX;
				distY = newPosY - that.absStartY;
				if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) { that.scrollTo(that.absStartX, that.absStartY, 200); }
				else {
					snap = that._snap(newPosX, newPosY);
					newPosX = snap.x;
					newPosY = snap.y;
					newDuration = m.max(snap.time, newDuration);
				}
			}

			that.scrollTo(m.round(newPosX), m.round(newPosY), newDuration);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		// Do we need to snap?
		if (that.options.snap) {
			distX = newPosX - that.absStartX;
			distY = newPosY - that.absStartY;
			if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) that.scrollTo(that.absStartX, that.absStartY, 200);
			else {
				snap = that._snap(that.x, that.y);
				if (snap.x != that.x || snap.y != that.y) that.scrollTo(snap.x, snap.y, snap.time);
			}

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		that._resetPos(200);
		if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
	},
	
	_resetPos: function (time) {
		var that = this,
			resetX = that.x >= 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x,
			resetY = that.y >= that.minScrollY || that.maxScrollY > 0 ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		if (resetX == that.x && resetY == that.y) {
			if (that.moved) {
				that.moved = false;
				if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);		// Execute custom code on scroll end
			}

			if (that.hScrollbar && that.options.hideScrollbar) {
				if (vendor == 'webkit') that.hScrollbarWrapper.style[transitionDelay] = '300ms';
				that.hScrollbarWrapper.style.opacity = '0';
			}
			if (that.vScrollbar && that.options.hideScrollbar) {
				if (vendor == 'webkit') that.vScrollbarWrapper.style[transitionDelay] = '300ms';
				that.vScrollbarWrapper.style.opacity = '0';
			}

			return;
		}

		that.scrollTo(resetX, resetY, time || 0);
	},

	_wheel: function (e) {
		var that = this,
			wheelDeltaX, wheelDeltaY,
			deltaX, deltaY,
			deltaScale;

		if ('wheelDeltaX' in e) {
			wheelDeltaX = e.wheelDeltaX / 12;
			wheelDeltaY = e.wheelDeltaY / 12;
		} else if('wheelDelta' in e) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 12;
		} else if ('detail' in e) {
			wheelDeltaX = wheelDeltaY = -e.detail * 3;
		} else {
			return;
		}
		
		if (that.options.wheelAction == 'zoom') {
			deltaScale = that.scale * Math.pow(2, 1/3 * (wheelDeltaY ? wheelDeltaY / Math.abs(wheelDeltaY) : 0));
			if (deltaScale < that.options.zoomMin) deltaScale = that.options.zoomMin;
			if (deltaScale > that.options.zoomMax) deltaScale = that.options.zoomMax;
			
			if (deltaScale != that.scale) {
				if (!that.wheelZoomCount && that.options.onZoomStart) that.options.onZoomStart.call(that, e);
				that.wheelZoomCount++;
				
				that.zoom(e.pageX, e.pageY, deltaScale, 400);
				
				setTimeout(function() {
					that.wheelZoomCount--;
					if (!that.wheelZoomCount && that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
				}, 400);
			}
			
			return;
		}
		
		deltaX = that.x + wheelDeltaX;
		deltaY = that.y + wheelDeltaY;

		if (deltaX > 0) deltaX = 0;
		else if (deltaX < that.maxScrollX) deltaX = that.maxScrollX;

		if (deltaY > that.minScrollY) deltaY = that.minScrollY;
		else if (deltaY < that.maxScrollY) deltaY = that.maxScrollY;
    
		if (that.maxScrollY < 0) {
			that.scrollTo(deltaX, deltaY, 0);
		}
	},
	
	_transitionEnd: function (e) {
		var that = this;

		if (e.target != that.scroller) return;

		that._unbind(TRNEND_EV);
		
		that._startAni();
	},


	/**
	*
	* Utilities
	*
	*/
	_startAni: function () {
		var that = this,
			startX = that.x, startY = that.y,
			startTime = Date.now(),
			step, easeOut,
			animate;

		if (that.animating) return;
		
		if (!that.steps.length) {
			that._resetPos(400);
			return;
		}
		
		step = that.steps.shift();
		
		if (step.x == startX && step.y == startY) step.time = 0;

		that.animating = true;
		that.moved = true;
		
		if (that.options.useTransition) {
			that._transitionTime(step.time);
			that._pos(step.x, step.y);
			that.animating = false;
			if (step.time) that._bind(TRNEND_EV);
			else that._resetPos(0);
			return;
		}

		animate = function () {
			var now = Date.now(),
				newX, newY;

			if (now >= startTime + step.time) {
				that._pos(step.x, step.y);
				that.animating = false;
				if (that.options.onAnimationEnd) that.options.onAnimationEnd.call(that);			// Execute custom code on animation end
				that._startAni();
				return;
			}

			now = (now - startTime) / step.time - 1;
			easeOut = m.sqrt(1 - now * now);
			newX = (step.x - startX) * easeOut + startX;
			newY = (step.y - startY) * easeOut + startY;
			that._pos(newX, newY);
			if (that.animating) that.aniTime = nextFrame(animate);
		};

		animate();
	},

	_transitionTime: function (time) {
		time += 'ms';
		this.scroller.style[transitionDuration] = time;
		if (this.hScrollbar) this.hScrollbarIndicator.style[transitionDuration] = time;
		if (this.vScrollbar) this.vScrollbarIndicator.style[transitionDuration] = time;
	},

	_momentum: function (dist, time, maxDistUpper, maxDistLower, size) {
		var deceleration = 0.0006,
			speed = m.abs(dist) / time,
			newDist = (speed * speed) / (2 * deceleration),
			newTime = 0, outsideDist = 0;

		// Proportinally reduce speed if we are outside of the boundaries
		if (dist > 0 && newDist > maxDistUpper) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistUpper = maxDistUpper + outsideDist;
			speed = speed * maxDistUpper / newDist;
			newDist = maxDistUpper;
		} else if (dist < 0 && newDist > maxDistLower) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistLower = maxDistLower + outsideDist;
			speed = speed * maxDistLower / newDist;
			newDist = maxDistLower;
		}

		newDist = newDist * (dist < 0 ? -1 : 1);
		newTime = speed / deceleration;

		return { dist: newDist, time: m.round(newTime) };
	},

	_offset: function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;
			
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		
		if (el != this.wrapper) {
			left *= this.scale;
			top *= this.scale;
		}

		return { left: left, top: top };
	},

	_snap: function (x, y) {
		var that = this,
			i, l,
			page, time,
			sizeX, sizeY;

		// Check page X
		page = that.pagesX.length - 1;
		for (i=0, l=that.pagesX.length; i<l; i++) {
			if (x >= that.pagesX[i]) {
				page = i;
				break;
			}
		}
		if (page == that.currPageX && page > 0 && that.dirX < 0) page--;
		x = that.pagesX[page];
		sizeX = m.abs(x - that.pagesX[that.currPageX]);
		sizeX = sizeX ? m.abs(that.x - x) / sizeX * 500 : 0;
		that.currPageX = page;

		// Check page Y
		page = that.pagesY.length-1;
		for (i=0; i<page; i++) {
			if (y >= that.pagesY[i]) {
				page = i;
				break;
			}
		}
		if (page == that.currPageY && page > 0 && that.dirY < 0) page--;
		y = that.pagesY[page];
		sizeY = m.abs(y - that.pagesY[that.currPageY]);
		sizeY = sizeY ? m.abs(that.y - y) / sizeY * 500 : 0;
		that.currPageY = page;

		// Snap with constant speed (proportional duration)
		time = m.round(m.max(sizeX, sizeY)) || 200;

		return { x: x, y: y, time: time };
	},

	_bind: function (type, el, bubble) {
		(el || this.scroller).addEventListener(type, this, !!bubble);
	},

	_unbind: function (type, el, bubble) {
		(el || this.scroller).removeEventListener(type, this, !!bubble);
	},


	/**
	*
	* Public methods
	*
	*/
	destroy: function () {
		var that = this;

		that.scroller.style[transform] = '';

		// Remove the scrollbars
		that.hScrollbar = false;
		that.vScrollbar = false;
		that._scrollbar('h');
		that._scrollbar('v');

		// Remove the event listeners
		that._unbind(RESIZE_EV, window);
		that._unbind(START_EV);
		that._unbind(MOVE_EV, window);
		that._unbind(END_EV, window);
		that._unbind(CANCEL_EV, window);
		
		if (!that.options.hasTouch) {
			that._unbind('DOMMouseScroll');
			that._unbind('mousewheel');
		}
		
		if (that.options.useTransition) that._unbind(TRNEND_EV);
		
		if (that.options.checkDOMChanges) clearInterval(that.checkDOMTime);
		
		if (that.options.onDestroy) that.options.onDestroy.call(that);
	},

	refresh: function () {
		var that = this,
			offset,
			i, l,
			els,
			pos = 0,
			page = 0;

		if (that.scale < that.options.zoomMin) that.scale = that.options.zoomMin;
		that.wrapperW = that.wrapper.clientWidth || 1;
		that.wrapperH = that.wrapper.clientHeight || 1;

		that.minScrollY = -that.options.topOffset || 0;
		that.scrollerW = m.round(that.scroller.offsetWidth * that.scale);
		that.scrollerH = m.round((that.scroller.offsetHeight + that.minScrollY) * that.scale);
		that.maxScrollX = that.wrapperW - that.scrollerW;
		that.maxScrollY = that.wrapperH - that.scrollerH + that.minScrollY;
		that.dirX = 0;
		that.dirY = 0;

		if (that.options.onRefresh) that.options.onRefresh.call(that);

		that.hScroll = that.options.hScroll && that.maxScrollX < 0;
		that.vScroll = that.options.vScroll && (!that.options.bounceLock && !that.hScroll || that.scrollerH > that.wrapperH);

		that.hScrollbar = that.hScroll && that.options.hScrollbar;
		that.vScrollbar = that.vScroll && that.options.vScrollbar && that.scrollerH > that.wrapperH;

		offset = that._offset(that.wrapper);
		that.wrapperOffsetLeft = -offset.left;
		that.wrapperOffsetTop = -offset.top;

		// Prepare snap
		if (typeof that.options.snap == 'string') {
			that.pagesX = [];
			that.pagesY = [];
			els = that.scroller.querySelectorAll(that.options.snap);
			for (i=0, l=els.length; i<l; i++) {
				pos = that._offset(els[i]);
				pos.left += that.wrapperOffsetLeft;
				pos.top += that.wrapperOffsetTop;
				that.pagesX[i] = pos.left < that.maxScrollX ? that.maxScrollX : pos.left * that.scale;
				that.pagesY[i] = pos.top < that.maxScrollY ? that.maxScrollY : pos.top * that.scale;
			}
		} else if (that.options.snap) {
			that.pagesX = [];
			while (pos >= that.maxScrollX) {
				that.pagesX[page] = pos;
				pos = pos - that.wrapperW;
				page++;
			}
			if (that.maxScrollX%that.wrapperW) that.pagesX[that.pagesX.length] = that.maxScrollX - that.pagesX[that.pagesX.length-1] + that.pagesX[that.pagesX.length-1];

			pos = 0;
			page = 0;
			that.pagesY = [];
			while (pos >= that.maxScrollY) {
				that.pagesY[page] = pos;
				pos = pos - that.wrapperH;
				page++;
			}
			if (that.maxScrollY%that.wrapperH) that.pagesY[that.pagesY.length] = that.maxScrollY - that.pagesY[that.pagesY.length-1] + that.pagesY[that.pagesY.length-1];
		}

		// Prepare the scrollbars
		that._scrollbar('h');
		that._scrollbar('v');

		if (!that.zoomed) {
			that.scroller.style[transitionDuration] = '0';
			that._resetPos(400);
		}
	},

	scrollTo: function (x, y, time, relative) {
		var that = this,
			step = x,
			i, l;

		that.stop();

		if (!step.length) step = [{ x: x, y: y, time: time, relative: relative }];
		
		for (i=0, l=step.length; i<l; i++) {
			if (step[i].relative) { step[i].x = that.x - step[i].x; step[i].y = that.y - step[i].y; }
			that.steps.push({ x: step[i].x, y: step[i].y, time: step[i].time || 0 });
		}

		that._startAni();
	},

	scrollToElement: function (el, time) {
		var that = this, pos;
		el = el.nodeType ? el : that.scroller.querySelector(el);
		if (!el) return;

		pos = that._offset(el);
		pos.left += that.wrapperOffsetLeft;
		pos.top += that.wrapperOffsetTop;

		pos.left = pos.left > 0 ? 0 : pos.left < that.maxScrollX ? that.maxScrollX : pos.left;
		pos.top = pos.top > that.minScrollY ? that.minScrollY : pos.top < that.maxScrollY ? that.maxScrollY : pos.top;
		time = time === undefined ? m.max(m.abs(pos.left)*2, m.abs(pos.top)*2) : time;

		that.scrollTo(pos.left, pos.top, time);
	},

	scrollToPage: function (pageX, pageY, time) {
		var that = this, x, y;
		
		time = time === undefined ? 400 : time;

		if (that.options.onScrollStart) that.options.onScrollStart.call(that);

		if (that.options.snap) {
			pageX = pageX == 'next' ? that.currPageX+1 : pageX == 'prev' ? that.currPageX-1 : pageX;
			pageY = pageY == 'next' ? that.currPageY+1 : pageY == 'prev' ? that.currPageY-1 : pageY;

			pageX = pageX < 0 ? 0 : pageX > that.pagesX.length-1 ? that.pagesX.length-1 : pageX;
			pageY = pageY < 0 ? 0 : pageY > that.pagesY.length-1 ? that.pagesY.length-1 : pageY;

			that.currPageX = pageX;
			that.currPageY = pageY;
			x = that.pagesX[pageX];
			y = that.pagesY[pageY];
		} else {
			x = -that.wrapperW * pageX;
			y = -that.wrapperH * pageY;
			if (x < that.maxScrollX) x = that.maxScrollX;
			if (y < that.maxScrollY) y = that.maxScrollY;
		}

		that.scrollTo(x, y, time);
	},

	disable: function () {
		this.stop();
		this._resetPos(0);
		this.enabled = false;

		// If disabled after touchstart we make sure that there are no left over events
		this._unbind(MOVE_EV, window);
		this._unbind(END_EV, window);
		this._unbind(CANCEL_EV, window);
	},
	
	enable: function () {
		this.enabled = true;
	},
	
	stop: function () {
		if (this.options.useTransition) this._unbind(TRNEND_EV);
		else cancelFrame(this.aniTime);
		this.steps = [];
		this.moved = false;
		this.animating = false;
	},
	
	zoom: function (x, y, scale, time) {
		var that = this,
			relScale = scale / that.scale;

		if (!that.options.useTransform) return;

		that.zoomed = true;
		time = time === undefined ? 200 : time;
		x = x - that.wrapperOffsetLeft - that.x;
		y = y - that.wrapperOffsetTop - that.y;
		that.x = x - x * relScale + that.x;
		that.y = y - y * relScale + that.y;

		that.scale = scale;
		that.refresh();

		that.x = that.x > 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x;
		that.y = that.y > that.minScrollY ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		that.scroller.style[transitionDuration] = time + 'ms';
		that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + scale + ')' + translateZ;
		that.zoomed = false;
	},
	
	isReady: function () {
		return !this.moved && !this.zoomed && !this.animating;
	}
};

function prefixStyle (style) {
	if ( vendor === '' ) return style;

	style = style.charAt(0).toUpperCase() + style.substr(1);
	return vendor + style;
}

dummyStyle = null;	// for the sake of it

if (typeof exports !== 'undefined') exports.iScroll = iScroll;
else window.iScroll = iScroll;

})(window, document);
;(function() {
  var $, eventName, features, findFirstChildWithClass, oppositeDirection, oppositeTransition, _i, _len, _ref;
  var __hasProp = Object.prototype.hasOwnProperty, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  };
  $ = x$;
  features = {
    vendor: /webkit/i.test(navigator.appVersion) ? 'webkit' : /firefox/i.test(navigator.userAgent) ? 'Moz' : 'opera' in window ? 'O' : '',
    isAndroid: /android/gi.test(navigator.appVersion)
  };
  features.useCssTransform = (!features.isAndroid) && (features.vendor + 'Transform' in document.documentElement.style);
  features.cssTransformPrefix = "-" + features.vendor.toLowerCase() + "-";
  features.transitionEndEvent = features.vendor === 'webkit' ? 'webkitTransitionEnd' : features.vendor === 'O' ? 'oTransitionEnd' : 'transitionend';
  $.isTouch = 'ontouchstart' in document.documentElement;
  $.clickOrTouch = $.isTouch ? 'touchstart' : 'click';
  features.supportsCssTouchScroll = typeof document.body.style.webkitOverflowScrolling !== "undefined";
  features.supportsIScroll = features.vendor === 'webkit' || features.vendor === "Moz";
  findFirstChildWithClass = function(elem, className) {
    var child;
    child = elem.firstChild;
    while (child) {
      if ($(child).hasClass(className)) {
        return child;
      }
      child = child.nextSibling;
    }
    return null;
  };
  oppositeDirection = {
    left: 'right',
    right: 'left',
    top: 'bottom',
    bottom: 'top'
  };
  oppositeTransition = function(transition) {
    var key;
    if (transition) {
      for (key in transition) {
        if (!__hasProp.call(transition, key)) continue;
        if ($.paneTransitionInverters.hasOwnProperty(key)) {
          return $.paneTransitionInverters[key](transition[key]);
        }
      }
    }
    return null;
  };
  $.getJSON = function(url, options) {
    var callback;
    callback = typeof options === "function" ? options : options.callback;
    return $(null).xhr(url, {
      method: options.method,
      async: true,
      data: JSON.stringify(options.data),
      headers: options.headers,
      callback: function() {
        return callback(JSON.parse(this.responseText));
      }
    });
  };
  $.map = function(items, map) {
    var item, mapped, results, _i, _len;
    results = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      mapped = map(item);
      if (mapped !== void 0) {
        results.push(mapped);
      }
    }
    return results;
  };
  $.fn.togglePane = function(show) {
    return this.each(function() {
      if (show) {
        this.style.display = 'block';
        if (this.isOffScreen) {
          this.isOffScreen = false;
          this.style.top = '';
          this.style.bottom = '';
        }
      } else {
        this.isOffScreen = true;
        this.style.top = '10000px';
        this.style.bottom = '-10000px';
      }
      return this;
    });
  };
  $.fn.afterNextTransition = function(callback) {
    return this.each(function() {
      var elem, handlerWrapper;
      elem = this;
      handlerWrapper = function() {
        callback.apply(this, arguments);
        return elem.removeEventListener(features.transitionEndEvent, handlerWrapper);
      };
      return elem.addEventListener(features.transitionEndEvent, handlerWrapper);
    });
  };
  $.fn.animateTranslation = function(finalPos, transition, callback) {
    callback = callback || function() {
      return {};
    };
    return this.each(function() {
      var $this, transform;
      $this = $(this);
      if (features.useCssTransform) {
        transform = {};
        transform[features.cssTransformPrefix + "transform"] = "translate(" + finalPos.left + ", " + finalPos.top + ")";
        transform[features.cssTransformPrefix + "transition"] = transition ? features.cssTransformPrefix + "transform 250ms ease-out" : null;
        if (transition) {
          $this.afterNextTransition(callback);
        }
        $this.css(transform);
        if (!transition) {
          return callback();
        }
      } else {
        if (transition) {
          return $this.tween(finalPos, callback);
        } else {
          $this.css(finalPos);
          return callback();
        }
      }
    });
  };
  $.fn.setPanePosition = function(position, transition, callback) {
    callback = callback || function() {
      return {};
    };
    return this.each(function() {
      var $this, finalPos, height, width, x, y;
      $this = $(this).togglePane(true);
      x = 0;
      y = 0;
      width = this.parentNode.offsetWidth;
      height = this.parentNode.offsetHeight;
      switch (position) {
        case 'right':
          x = width;
          break;
        case 'left':
          x = -1 * width;
          break;
        case 'top':
          y = -1 * height;
          break;
        case 'bottom':
          y = height;
      }
      finalPos = {
        left: x + 'px',
        right: (-1 * x) + 'px',
        top: y + 'px',
        bottom: (-1 * y) + 'px'
      };
      return $this.animateTranslation(finalPos, transition, callback);
    });
  };
  $.fn.slidePane = function(options) {
    return this.each(function() {
      var $this, afterSlide;
      $this = $(this);
      afterSlide = function() {
        if (options.to) {
          $this.togglePane(false);
        }
        if (options.callback) {
          return options.callback();
        }
      };
      return $this.setPanePosition(options.from, null).setPanePosition(options.to, true, afterSlide);
    });
  };
  $.fn.showPane = function(options) {
    options = options || {};
    return this.each(function() {
      var activePane, transitionKey, transitionToUse, _ref;
      activePane = findFirstChildWithClass(this.parentNode, "active");
      if (activePane !== this) {
        $(this).has(".scroll-y.autoscroll").touchScroll({
          hScroll: false
        });
        $(this).has(".scroll-x.autoscroll").touchScroll({
          yScroll: false
        });
        transitionToUse = 'default';
        _ref = $.paneTransitions;
        for (transitionKey in _ref) {
          if (!__hasProp.call(_ref, transitionKey)) continue;
          if (options.hasOwnProperty(transitionKey)) {
            transitionToUse = transitionKey;
            break;
          }
        }
        $.paneTransitions[transitionKey](this, activePane, options[transitionKey]);
        $(this).addClass("active");
        if (activePane) {
          return $(activePane).removeClass("active");
        }
      }
    });
  };
  $.fn.showBySlidingParent = function() {
    return this.each(function() {
      var finalPos, targetPaneOffsetLeft, targetPaneOffsetTop;
      targetPaneOffsetLeft = this.style.left || '0px';
      targetPaneOffsetTop = this.style.top || '0px';
      finalPos = {
        left: '-' + targetPaneOffsetLeft,
        right: targetPaneOffsetLeft,
        top: '-' + targetPaneOffsetTop,
        bottom: targetPaneOffsetTop
      };
      $(this.parentNode).animateTranslation(finalPos, true);
      return this;
    });
  };
  $.fn.touchScroll = function(options) {
    if ((!features.supportsCssTouchScroll) && features.supportsIScroll) {
      this.each(function() {
        var doRefresh;
        if (!this.hasIScroll) {
          this.hasIScroll = new iScroll(this, options);
        }
        doRefresh = __bind(function() {
          return this.hasIScroll.refresh();
        }, this);
        setTimeout(doRefresh, 0);
        return this;
      });
    }
    return this;
  };
  $.fn.clickOrTouch = function(handler) {
    return this.on($.clickOrTouch, handler);
  };
  _ref = ['click'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    eventName = _ref[_i];
    if (!$.fn[eventName]) {
      $.fn[eventName] = function(handler) {
        return this.on(eventName, handler);
      };
    }
  }
  $.paneTransitions = {
    slideFrom: function(incomingPane, outgoingPane, options) {
      $(incomingPane).slidePane({
        from: options
      });
      if (outgoingPane) {
        return $(outgoingPane).slidePane({
          to: oppositeDirection[options]
        });
      }
    },
    coverFrom: function(incomingPane, outgoingPane, options) {
      var outgoingZIndex;
      outgoingZIndex = (outgoingPane != null ? outgoingPane.style.zIndex : void 0) || 0;
      return $(incomingPane).css({
        zIndex: outgoingZIndex + 1
      }).slidePane({
        from: options,
        callback: function() {
          return $(outgoingPane).togglePane(false);
        }
      });
    },
    uncoverTo: function(incomingPane, outgoingPane, options) {
      var incomingZIndex;
      incomingZIndex = incomingPane.style.zIndex || 0;
      $(incomingPane).togglePane(true).setPanePosition();
      return $(outgoingPane).css({
        zIndex: incomingZIndex + 1
      }).slidePane({
        to: options
      });
    },
    "default": function(incomingPane, outgoingPane, options) {
      $(incomingPane).togglePane(true).setPanePosition();
      return $(outgoingPane).togglePane(false);
    }
  };
  $.paneTransitionInverters = {
    slideFrom: function(direction) {
      return {
        slideFrom: oppositeDirection[direction]
      };
    },
    coverFrom: function(direction) {
      return {
        uncoverTo: direction
      };
    },
    uncoverTo: function(direction) {
      return {
        coverFrom: direction
      };
    }
  };
  window.PaneHistory = (function() {
    function PaneHistory(initialEntries) {
      var _ref2;
      this.entries = initialEntries || [];
      this.position = this.entries.length - 1;
      if (((_ref2 = window.ko) != null ? _ref2.observable : void 0) != null) {
        this.current = window.ko.observable();
        this.refreshCurrent();
      }
    }
    PaneHistory.prototype.relative = function(offset) {
      return this.entries.slice(this.position + offset, this.position + offset + 1)[0];
    };
    PaneHistory.prototype.current = function() {
      return this.relative(0) || {
        paneData: {},
        paneIndex: void 0
      };
    };
    PaneHistory.prototype.currentData = function() {
      return this.current().paneData;
    };
    PaneHistory.prototype.refreshCurrent = function() {
      return this.current(this.relative(0) || {
        paneData: {},
        paneIndex: void 0
      });
    };
    PaneHistory.prototype.count = function() {
      return this.entries.slice(0).length;
    };
    PaneHistory.prototype.showCurrentPane = function(transition) {
      return $('#' + this.current().paneId).showPane(transition || this.current().transition);
    };
    PaneHistory.prototype.navigate = function(paneId, paneData, transition) {
      var deleteCount, transitionToUse;
      deleteCount = this.count() - (this.position + 1);
      this.entries.splice(this.position + 1, deleteCount);
      transitionToUse = transition !== void 0 ? transition : this.position >= 0 ? {
        slideFrom: "right"
      } : null;
      this.entries.push({
        paneId: paneId,
        paneData: paneData,
        paneIndex: this.entries.slice(0).length,
        transition: transitionToUse
      });
      this.position++;
      this.refreshCurrent();
      return this.showCurrentPane();
    };
    PaneHistory.prototype.back = function(transition) {
      var currentTransition, transitionToUse;
      if (this.position > 0) {
        currentTransition = this.current().transition;
        this.position--;
        this.refreshCurrent();
        transitionToUse = transition !== void 0 ? transition : oppositeTransition(currentTransition);
        return this.showCurrentPane(transitionToUse);
      }
    };
    return PaneHistory;
  })();
  window.UrlLinkedPaneHistory = (function() {
    __extends(UrlLinkedPaneHistory, window.PaneHistory);
    function UrlLinkedPaneHistory(options) {
      var handleStateChange;
      UrlLinkedPaneHistory.__super__.constructor.call(this, options.entries);
      this.urlLinkOptions = options;
      handleStateChange = __bind(function() {
        return this.navigate(this.getCurrentUrlParams(), void 0, true);
      }, this);
      handleStateChange();
      History.Adapter.bind(window, 'statechange', handleStateChange);
    }
    UrlLinkedPaneHistory.prototype.getCurrentUrlParams = function() {
      var allUrlParams;
      allUrlParams = this._parseQueryString(History.getState().url);
      return this._extractProperties(allUrlParams, this.urlLinkOptions.params);
    };
    UrlLinkedPaneHistory.prototype.setCurrentUrlParams = function(params) {
      var key, newUrl, urlValues, _ref2;
      urlValues = this._parseQueryString(History.getState().url);
      _ref2 = this.urlLinkOptions.params;
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        if (params.hasOwnProperty(key) && (params[key] !== this.urlLinkOptions.params[key])) {
          urlValues[key] = params[key];
        } else {
          delete urlValues[key];
        }
      }
      newUrl = this._formatQueryString(urlValues);
      return History.pushState(null, null, newUrl);
    };
    UrlLinkedPaneHistory.prototype.navigate = function(params, transition, isExternalNavigation) {
      var forwardsEntry, onLoadedData, paneId, _ref2, _ref3;
      paneId = this._createPaneId(params);
      if (((_ref2 = this.current()) != null ? _ref2.paneId : void 0) === paneId) {
        return;
      }
      if (((_ref3 = this.relative(-1)) != null ? _ref3.paneId : void 0) === paneId) {
        if (isExternalNavigation) {
          UrlLinkedPaneHistory.__super__.back.call(this, transition);
        } else {
          History.back();
        }
        return;
      }
      forwardsEntry = this.relative(1);
      if (forwardsEntry && (forwardsEntry.paneId === paneId)) {
        if (transition === void 0) {
          transition = forwardsEntry.transition;
        }
      }
      onLoadedData = __bind(function(data, transitionOverride) {
        UrlLinkedPaneHistory.__super__.navigate.call(this, paneId, data, transitionOverride || transition);
        if (!isExternalNavigation) {
          return this.setCurrentUrlParams(params);
        }
      }, this);
      return setTimeout((__bind(function() {
        if (this.urlLinkOptions.loadPaneData) {
          return this.urlLinkOptions.loadPaneData.call(this, params, onLoadedData);
        } else {
          return onLoadedData(null);
        }
      }, this)), 0);
    };
    UrlLinkedPaneHistory.prototype.back = function() {
      throw new Error('Cannot use "back" on specific URL-linked history trackers, because URL history is global. Use History.back() instead.');
    };
    UrlLinkedPaneHistory.prototype._parseQueryString = function(url) {
      var pair, query, result, tokens, _j, _len2, _ref2;
      if (url.indexOf('?') < 0) {
        return {};
      }
      query = url.substring(url.lastIndexOf('?') + 1);
      result = {};
      _ref2 = query.split("&");
      for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
        pair = _ref2[_j];
        tokens = pair.split("=");
        if (tokens.length === 2) {
          result[tokens[0]] = decodeURIComponent(tokens[1]);
        }
      }
      return result;
    };
    UrlLinkedPaneHistory.prototype._formatQueryString = function(params) {
      var formattedUrl, key, value;
      formattedUrl = '?';
      for (key in params) {
        if (!__hasProp.call(params, key)) continue;
        value = params[key];
        if (formattedUrl !== '?') {
          formattedUrl += '&';
        }
        formattedUrl += key + '=' + encodeURIComponent(value);
      }
      return formattedUrl;
    };
    UrlLinkedPaneHistory.prototype._createPaneId = function(params) {
      var id, key, paramsWithDefaults;
      paramsWithDefaults = this._extractProperties(params, this.urlLinkOptions.params);
      id = '';
      for (key in paramsWithDefaults) {
        if (!__hasProp.call(paramsWithDefaults, key)) continue;
        if (id) {
          id += '_';
        }
        id += key + '-' + paramsWithDefaults[key];
      }
      return (this.urlLinkOptions.idPrefix || '') + id;
    };
    UrlLinkedPaneHistory.prototype._extractProperties = function(obj, propertiesWithDefaults) {
      var key, result;
      result = {};
      for (key in propertiesWithDefaults) {
        if (!__hasProp.call(propertiesWithDefaults, key)) continue;
        result[key] = obj.hasOwnProperty(key) ? obj[key] : propertiesWithDefaults[key];
      }
      return result;
    };
    return UrlLinkedPaneHistory;
  })();
}).call(this);
;/*! TinySort 1.5.3
* Copyright (c) 2008-2013 Ron Valstar http://tinysort.sjeiti.com/
*
* Dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*//*
* Description:
*   A jQuery plugin to sort child nodes by (sub) contents or attributes.
*
* Contributors:
*	brian.gibson@gmail.com
*	michael.thornberry@gmail.com
*
* Usage:
*   $("ul#people>li").tsort();
*   $("ul#people>li").tsort("span.surname");
*   $("ul#people>li").tsort("span.surname",{order:"desc"});
*   $("ul#people>li").tsort({place:"end"});
*   $("ul#people>li").tsort("span.surname",{order:"desc"},span.name");
*
* Change default like so:
*   $.tinysort.defaults.order = "desc";
*
*/
;(function($,undefined) {
	// private vars
	var fls = !1							// minify placeholder
		,nll = null							// minify placeholder
		,prsflt = parseFloat				// minify	 placeholder
		,mathmn = Math.min					// minify placeholder
		,rxLastNr = /(-?\d+\.?\d*)$/g		// regex for testing strings ending on numbers
		,rxLastNrNoDash = /(\d+\.?\d*)$/g	// regex for testing strings ending on numbers ignoring dashes
		,aPluginPrepare = []
		,aPluginSort = []
		,isString = function(o){return typeof o=='string';}
		// Array.prototype.indexOf for IE (issue #26) (local variable to prevent unwanted prototype pollution)
		,fnIndexOf = Array.prototype.indexOf||function(elm) {
			var len = this.length
				,from = Number(arguments[1])||0;
			from = from<0?Math.ceil(from):Math.floor(from);
			if (from<0) from += len;
			for (;from<len;from++){
				if (from in this && this[from]===elm) return from;
			}
			return -1;
		}
	;
	//
	// init plugin
	$.tinysort = {
		 id: 'TinySort'
		,version: '1.5.2'
		,copyright: 'Copyright (c) 2008-2013 Ron Valstar'
		,uri: 'http://tinysort.sjeiti.com/'
		,licensed: {
			MIT: 'http://www.opensource.org/licenses/mit-license.php'
			,GPL: 'http://www.gnu.org/licenses/gpl.html'
		}
		,plugin: (function(){
			var fn = function(prepare,sort){
				aPluginPrepare.push(prepare);	// function(settings){doStuff();}
				aPluginSort.push(sort);			// function(valuesAreNumeric,sA,sB,iReturn){doStuff();return iReturn;}
			};
			// expose stuff to plugins
			fn.indexOf = fnIndexOf;
			return fn;
		})()
		,defaults: { // default settings

			 order: 'asc'			// order: asc, desc or rand

			,attr: nll				// order by attribute value
			,data: nll				// use the data attribute for sorting
			,useVal: fls			// use element value instead of text

			,place: 'start'			// place ordered elements at position: start, end, org (original position), first
			,returns: fls			// return all elements or only the sorted ones (true/false)

			,cases: fls				// a case sensitive sort orders [aB,aa,ab,bb]
			,forceStrings:fls		// if false the string '2' will sort with the value 2, not the string '2'

			,ignoreDashes:fls		// ignores dashes when looking for numerals

			,sortFunction: nll		// override the default sort function
		}
	};
	$.fn.extend({
		tinysort: function() {
			var i,l
				,oThis = this
				,aNewOrder = []
				// sortable- and non-sortable list per parent
				,aElements = []
				,aElementsParent = [] // index reference for parent to aElements
				// multiple sort criteria (sort===0?iCriteria++:iCriteria=0)
				,aCriteria = []
				,iCriteria = 0
				,iCriteriaMax
				//
				,aFind = []
				,aSettings = []
				//
				,fnPluginPrepare = function(_settings){
					$.each(aPluginPrepare,function(i,fn){
						fn.call(fn,_settings);
					});
				}
				//
				,fnSort = function(a,b) {
					var iReturn = 0;
					if (iCriteria!==0) iCriteria = 0;
					while (iReturn===0&&iCriteria<iCriteriaMax) {
						var oPoint = aCriteria[iCriteria]
							,oSett = oPoint.oSettings
							,rxLast = oSett.ignoreDashes?rxLastNrNoDash:rxLastNr
						;
						//
						fnPluginPrepare(oSett);
						//
						if (oSett.sortFunction) { // custom sort
							iReturn = oSett.sortFunction(a,b);
						} else if (oSett.order=='rand') { // random sort
							iReturn = Math.random()<.5?1:-1;
						} else { // regular sort
							var bNumeric = fls
							// maybe toLower
								,sA = !oSett.cases?toLowerCase(a.s[iCriteria]):a.s[iCriteria]
								,sB = !oSett.cases?toLowerCase(b.s[iCriteria]):b.s[iCriteria];
							// maybe force Strings
							if (!oSettings.forceStrings) {
								// maybe mixed
								var  aAnum = isString(sA)?sA&&sA.match(rxLast):fls
									,aBnum = isString(sB)?sB&&sB.match(rxLast):fls;
								if (aAnum&&aBnum) {
									var  sAprv = sA.substr(0,sA.length-aAnum[0].length)
										,sBprv = sB.substr(0,sB.length-aBnum[0].length);
									if (sAprv==sBprv) {
										bNumeric = !fls;
										sA = prsflt(aAnum[0]);
										sB = prsflt(aBnum[0]);
									}
								}
							}
							iReturn = oPoint.iAsc*(sA<sB?-1:(sA>sB?1:0));
						}

						$.each(aPluginSort,function(i,fn){
							iReturn = fn.call(fn,bNumeric,sA,sB,iReturn);
						});

						if (iReturn===0) iCriteria++;
					}

					return iReturn;
				}
			;
			// fill aFind and aSettings but keep length pairing up
			for (i=0,l=arguments.length;i<l;i++){
				var o = arguments[i];
				if (isString(o))	{
					if (aFind.push(o)-1>aSettings.length) aSettings.length = aFind.length-1;
				} else {
					if (aSettings.push(o)>aFind.length) aFind.length = aSettings.length;
				}
			}
			if (aFind.length>aSettings.length) aSettings.length = aFind.length; // todo: and other way around?

			// fill aFind and aSettings for arguments.length===0
			iCriteriaMax = aFind.length;
			if (iCriteriaMax===0) {
				iCriteriaMax = aFind.length = 1;
				aSettings.push({});
			}

			for (i=0,l=iCriteriaMax;i<l;i++) {
				var sFind = aFind[i]
					,oSettings = $.extend({}, $.tinysort. defaults, aSettings[i])
					// has find, attr or data
					,bFind = !(!sFind||sFind=='')
					// since jQuery's filter within each works on array index and not actual index we have to create the filter in advance
					,bFilter = bFind&&sFind[0]==':'
				;
				aCriteria.push({ // todo: only used locally, find a way to minify properties
					 sFind: sFind
					,oSettings: oSettings
					// has find, attr or data
					,bFind: bFind
					,bAttr: !(oSettings.attr===nll||oSettings.attr=='')
					,bData: oSettings.data!==nll
					// filter
					,bFilter: bFilter
					,$Filter: bFilter?oThis.filter(sFind):oThis
					,fnSort: oSettings.sortFunction
					,iAsc: oSettings.order=='asc'?1:-1
				});
			}
			//
			// prepare oElements for sorting
			oThis.each(function(i,el) {
				var $Elm = $(el)
					,mParent = $Elm.parent().get(0)
					,mFirstElmOrSub // we still need to distinguish between sortable and non-sortable elements (might have unexpected results for multiple criteria)
					,aSort = []
				;
				for (j=0;j<iCriteriaMax;j++) {
					var oPoint = aCriteria[j]
						// element or sub selection
						,mElmOrSub = oPoint.bFind?(oPoint.bFilter?oPoint.$Filter.filter(el):$Elm.find(oPoint.sFind)):$Elm;
					// text or attribute value
					aSort.push(oPoint.bData?mElmOrSub.data(oPoint.oSettings.data):(oPoint.bAttr?mElmOrSub.attr(oPoint.oSettings.attr):(oPoint.oSettings.useVal?mElmOrSub.val():mElmOrSub.text())));
					if (mFirstElmOrSub===undefined) mFirstElmOrSub = mElmOrSub;
				}
				// to sort or not to sort
				var iElmIndex = fnIndexOf.call(aElementsParent,mParent);
				if (iElmIndex<0) {
					iElmIndex = aElementsParent.push(mParent) - 1;
					aElements[iElmIndex] = {s:[],n:[]};	// s: sort, n: not sort
				}
				if (mFirstElmOrSub.length>0)	aElements[iElmIndex].s.push({s:aSort,e:$Elm,n:i}); // s:string/pointer, e:element, n:number
				else							aElements[iElmIndex].n.push({e:$Elm,n:i});
			});
			//
			// sort
			$.each(aElements, function(j,oParent) { oParent.s.sort(fnSort); });
			//
			// order elements and fill new order
			$.each(aElements, function(j,oParent) {
//				var oParent = aElements[j]
				var iNumElm = oParent.s.length
					,aOrg = [] // list for original position
					,iLow = iNumElm
					,aCnt = [0,0] // count how much we've sorted for retreival from either the sort list or the non-sort list (oParent.s/oParent.n)
				;
				switch (oSettings.place) {
					case 'first':	$.each(oParent.s,function(i,obj) { iLow = mathmn(iLow,obj.n) }); break;
					case 'org':		$.each(oParent.s,function(i,obj) { aOrg.push(obj.n) }); break;
					case 'end':		iLow = oParent.n.length; break;
					default:		iLow = 0;
				}
				for (i=0;i<iNumElm;i++) {
					var bSList = contains(aOrg,i)?!fls:i>=iLow&&i<iLow+oParent.s.length
						,mEl = (bSList?oParent.s:oParent.n)[aCnt[bSList?0:1]].e;
					mEl.parent().append(mEl);
					if (bSList||!oSettings.returns) aNewOrder.push(mEl.get(0));
					aCnt[bSList?0:1]++;
				}
			});
			oThis.length = 0;
			Array.prototype.push.apply(oThis,aNewOrder);
			return oThis;
		}
	});
	// toLowerCase
	function toLowerCase(s) {
		return s&&s.toLowerCase?s.toLowerCase():s;
	}
	// array contains
	function contains(a,n) {
		for (var i=0,l=a.length;i<l;i++) if (a[i]==n) return !fls;
		return fls;
	}
	// set functions
	$.fn.TinySort = $.fn.Tinysort = $.fn.tsort = $.fn.tinysort;
})(jQuery);;/*!
 * ruto.js, yet another simple hash router
 *
 * Copyright 2012, Lim Chee Aun (http://cheeaun.com/)
 * Licensed under the MIT license.
 * http://cheeaun.mit-license.org/
 */

(function(w){
	var routes = [],
		noop = function(){},
		options = {
			defaultPath: '/',
			before: noop,
			on: noop,
			notfound: noop
		};

	var ruto = {
		current: null,
		previous: null,
		config: function(opts){
			for (var o in opts){
				if (opts.hasOwnProperty(o)) options[o] = opts[o];
			}
			return ruto;
		},
		add: function(path, name, fn){
			if (path && name){
				if (typeof name == 'function'){
					fn = name;
					name = null;
				}
				routes.push({
					path: path,
					name: name,
					fn: fn || function(){}
				});
			}
			return ruto;
		},
		go: function(path){
			location.hash = path;
			return ruto;
		},
		back: function(path){
			// Only 1-step back
			if (ruto.previous){
				history.back();
				ruto.previous = null;
			} else if (path){ // Fallback if can't go back
				location.hash = path;
			}
			return ruto;
		}
	};

	var hashchange = function(){
		var hash = location.hash.slice(1),
			found = false,
			current = ruto.current;

		if (!hash) hash = options.defaultPath;

		if (current && current != ruto.previous){
			ruto.previous = current;
		}
		ruto.current = hash;

		for (var i=0, l=routes.length; i<l && !found; i++){
			var route = routes[i],
				path = route.path,
				name = route.name,
				fn = route.fn;
			if (typeof path == 'string'){
				if (path.toLowerCase() == hash.toLowerCase()){
					options.before.call(ruto, path, name);
					fn.call(ruto);
					options.on.call(ruto, path, name);
					found = true;
				}
			} else { // regexp
				var matches = hash.match(path);
				if (matches){
					options.before.call(ruto, path, name, matches);
					fn.apply(ruto, matches);
					options.on.call(ruto, path, name, matches);
					found = true;
				}
			}
		}

		if (!found) options.notfound.call(ruto);

		return ruto;
	};
	ruto.init = function(path){
		w.addEventListener('hashchange', hashchange);
		return hashchange();
	};
	ruto.reload = hashchange;

	w.ruto = ruto;
})(window);;/*!
 * Amplify Store - Persistent Client-Side Storage 1.1.0
 *
 * Copyright 2012 appendTo LLC. (http://appendto.com/team)
 * Dual licensed under the MIT or GPL licenses.
 * http://appendto.com/open-source-licenses
 *
 * http://amplifyjs.com
 */
(function( amplify, undefined ) {

var store = amplify.store = function( key, value, options ) {
	var type = store.type;
	if ( options && options.type && options.type in store.types ) {
		type = options.type;
	}
	return store.types[ type ]( key, value, options || {} );
};

store.types = {};
store.type = null;
store.addType = function( type, storage ) {
	if ( !store.type ) {
		store.type = type;
	}

	store.types[ type ] = storage;
	store[ type ] = function( key, value, options ) {
		options = options || {};
		options.type = type;
		return store( key, value, options );
	};
};
store.error = function() {
	return "amplify.store quota exceeded";
};

var rprefix = /^__amplify__/;
function createFromStorageInterface( storageType, storage ) {
	store.addType( storageType, function( key, value, options ) {
		var storedValue, parsed, i, remove,
			ret = value,
			now = (new Date()).getTime();

		if ( !key ) {
			ret = {};
			remove = [];
			i = 0;
			try {
				// accessing the length property works around a localStorage bug
				// in Firefox 4.0 where the keys don't update cross-page
				// we assign to key just to avoid Closure Compiler from removing
				// the access as "useless code"
				// https://bugzilla.mozilla.org/show_bug.cgi?id=662511
				key = storage.length;

				while ( key = storage.key( i++ ) ) {
					if ( rprefix.test( key ) ) {
						parsed = JSON.parse( storage.getItem( key ) );
						if ( parsed.expires && parsed.expires <= now ) {
							remove.push( key );
						} else {
							ret[ key.replace( rprefix, "" ) ] = parsed.data;
						}
					}
				}
				while ( key = remove.pop() ) {
					storage.removeItem( key );
				}
			} catch ( error ) {}
			return ret;
		}

		// protect against name collisions with direct storage
		key = "__amplify__" + key;

		if ( value === undefined ) {
			storedValue = storage.getItem( key );
			parsed = storedValue ? JSON.parse( storedValue ) : { expires: -1 };
			if ( parsed.expires && parsed.expires <= now ) {
				storage.removeItem( key );
			} else {
				return parsed.data;
			}
		} else {
			if ( value === null ) {
				storage.removeItem( key );
			} else {
				parsed = JSON.stringify({
					data: value,
					expires: options.expires ? now + options.expires : null
				});
				try {
					storage.setItem( key, parsed );
				// quota exceeded
				} catch( error ) {
					// expire old data and try again
					store[ storageType ]();
					try {
						storage.setItem( key, parsed );
					} catch( error ) {
						throw store.error();
					}
				}
			}
		}

		return ret;
	});
}

// localStorage + sessionStorage
// IE 8+, Firefox 3.5+, Safari 4+, Chrome 4+, Opera 10.5+, iPhone 2+, Android 2+
for ( var webStorageType in { localStorage: 1, sessionStorage: 1 } ) {
	// try/catch for file protocol in Firefox and Private Browsing in Safari 5
	try {
		// Safari 5 in Private Browsing mode exposes localStorage
		// but doesn't allow storing data, so we attempt to store and remove an item.
		// This will unfortunately give us a false negative if we're at the limit.
		window[ webStorageType ].setItem( "__amplify__", "x" );
		window[ webStorageType ].removeItem( "__amplify__" );
		createFromStorageInterface( webStorageType, window[ webStorageType ] );
	} catch( e ) {}
}

// globalStorage
// non-standard: Firefox 2+
// https://developer.mozilla.org/en/dom/storage#globalStorage
if ( !store.types.localStorage && window.globalStorage ) {
	// try/catch for file protocol in Firefox
	try {
		createFromStorageInterface( "globalStorage",
			window.globalStorage[ window.location.hostname ] );
		// Firefox 2.0 and 3.0 have sessionStorage and globalStorage
		// make sure we default to globalStorage
		// but don't default to globalStorage in 3.5+ which also has localStorage
		if ( store.type === "sessionStorage" ) {
			store.type = "globalStorage";
		}
	} catch( e ) {}
}

// userData
// non-standard: IE 5+
// http://msdn.microsoft.com/en-us/library/ms531424(v=vs.85).aspx
(function() {
	// IE 9 has quirks in userData that are a huge pain
	// rather than finding a way to detect these quirks
	// we just don't register userData if we have localStorage
	if ( store.types.localStorage ) {
		return;
	}

	// append to html instead of body so we can do this from the head
	var div = document.createElement( "div" ),
		attrKey = "amplify";
	div.style.display = "none";
	document.getElementsByTagName( "head" )[ 0 ].appendChild( div );

	// we can't feature detect userData support
	// so just try and see if it fails
	// surprisingly, even just adding the behavior isn't enough for a failure
	// so we need to load the data as well
	try {
		div.addBehavior( "#default#userdata" );
		div.load( attrKey );
	} catch( e ) {
		div.parentNode.removeChild( div );
		return;
	}

	store.addType( "userData", function( key, value, options ) {
		div.load( attrKey );
		var attr, parsed, prevValue, i, remove,
			ret = value,
			now = (new Date()).getTime();

		if ( !key ) {
			ret = {};
			remove = [];
			i = 0;
			while ( attr = div.XMLDocument.documentElement.attributes[ i++ ] ) {
				parsed = JSON.parse( attr.value );
				if ( parsed.expires && parsed.expires <= now ) {
					remove.push( attr.name );
				} else {
					ret[ attr.name ] = parsed.data;
				}
			}
			while ( key = remove.pop() ) {
				div.removeAttribute( key );
			}
			div.save( attrKey );
			return ret;
		}

		// convert invalid characters to dashes
		// http://www.w3.org/TR/REC-xml/#NT-Name
		// simplified to assume the starting character is valid
		// also removed colon as it is invalid in HTML attribute names
		key = key.replace( /[^\-._0-9A-Za-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c-\u200d\u203f\u2040\u2070-\u218f]/g, "-" );
		// adjust invalid starting character to deal with our simplified sanitization
		key = key.replace( /^-/, "_-" );

		if ( value === undefined ) {
			attr = div.getAttribute( key );
			parsed = attr ? JSON.parse( attr ) : { expires: -1 };
			if ( parsed.expires && parsed.expires <= now ) {
				div.removeAttribute( key );
			} else {
				return parsed.data;
			}
		} else {
			if ( value === null ) {
				div.removeAttribute( key );
			} else {
				// we need to get the previous value in case we need to rollback
				prevValue = div.getAttribute( key );
				parsed = JSON.stringify({
					data: value,
					expires: (options.expires ? (now + options.expires) : null)
				});
				div.setAttribute( key, parsed );
			}
		}

		try {
			div.save( attrKey );
		// quota exceeded
		} catch ( error ) {
			// roll the value back to the previous value
			if ( prevValue === null ) {
				div.removeAttribute( key );
			} else {
				div.setAttribute( key, prevValue );
			}

			// expire old data and try again
			store.userData();
			try {
				div.setAttribute( key, parsed );
				div.save( attrKey );
			} catch ( error ) {
				// roll the value back to the previous value
				if ( prevValue === null ) {
					div.removeAttribute( key );
				} else {
					div.setAttribute( key, prevValue );
				}
				throw store.error();
			}
		}
		return ret;
	});
}() );

// in-memory storage
// fallback for all browsers to enable the API even if we can't persist data
(function() {
	var memory = {},
		timeout = {};

	function copy( obj ) {
		return obj === undefined ? undefined : JSON.parse( JSON.stringify( obj ) );
	}

	store.addType( "memory", function( key, value, options ) {
		if ( !key ) {
			return copy( memory );
		}

		if ( value === undefined ) {
			return copy( memory[ key ] );
		}

		if ( timeout[ key ] ) {
			clearTimeout( timeout[ key ] );
			delete timeout[ key ];
		}

		if ( value === null ) {
			delete memory[ key ];
			return null;
		}

		memory[ key ] = value;
		if ( options.expires ) {
			timeout[ key ] = setTimeout(function() {
				delete memory[ key ];
				delete timeout[ key ];
			}, options.expires );
		}

		return value;
	});
}() );

}( this.amplify = this.amplify || {} ) );
;/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

var Hogan = {};

(function (Hogan, useArrayBuffer) {
  Hogan.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || '';
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.ib();
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we've instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance && partial.base == template) {
        return partial.instance;
      }

      if (typeof template == 'string') {
        if (!this.c) {
          throw new Error("No compiler available.");
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (this.activeSub === undefined) {
          // Store parent template text in partials.stackText to perform substitutions in child templates correctly
          partials.stackText  = this.text;
        }
         template = createSpecializedPartial(template, partial.subs, partial.partials, partials.stackText || this.text);
       }
      this.partials[symbol].instance = template;
      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return '';
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val == 'function') {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === '.' && isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i < names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found != null) {
            cx = val;
            val = found;
          } else {
            val = '';
          }
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val == 'function') {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val != null) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : "";
      }

      if (!returnFound && typeof val == 'function') {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error('Lambda features disabled.');
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: (useArrayBuffer) ? function(s) { this.buf.push(s); } :
                          function(s) { this.buf += s; },

    fl: (useArrayBuffer) ? function() { var r = this.buf.join(''); this.buf = []; return r; } :
                           function() { var r = this.buf; this.buf = ''; return r; },
    // init the buffer
    ib: function () {
      this.buf = (useArrayBuffer) ? [] : '';
    },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result == 'function') {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result == 'function') {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }

  };

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val, checkVal;

    if (scope && typeof scope == 'object') {

      if (scope[key] != null) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet && scope.get && typeof scope.get == 'function') {
        val = scope.get(key);
      }
    }

    return val;
  }

  function createSpecializedPartial(instance, subs, partials, childText) {
    function PartialTemplate() {};
    PartialTemplate.prototype = instance;
    function Substitutions() {};
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.ib();

    for (key in subs) {
      partial.subs[key] = subs[key];
      partial.subsText[key] = childText;
    }

    for (key in partials) {
      partial.partials[key] = partials[key];
    }

    return partial;
  }

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  };

})(typeof exports !== 'undefined' ? exports : Hogan);
;(function(w){
	
	var date = function(){ return +new Date(); },
		supportXDomainRequest = !!w.XDomainRequest,
		supportCORS = 'withCredentials' in new XMLHttpRequest() || supportXDomainRequest,
		worker = false,
		timeout = 20000, // 20 seconds timeout
		requests = {};

	try {
		worker = new Worker('js/hnapi-worker.js');
		worker.addEventListener('message', function(e){
			var data = e.data,
				url = data.url || '';
			if (!requests[url]) return;
			var r = requests[url];
			if (data.error){
				r.error(data.error);
			} else {
				r.success(data.response);
			}
			delete requests[url];
		}, false);
	} catch (e){}

	var req = function(url, success, error){
			if (!success) success = function(){};
			if (!error) error = function(){};
			if (supportCORS){
				if (worker){
					requests[url] = {
						success: success,
						error: error
					};
					worker.postMessage({
						url: url,
						timeout: timeout
					});
				} else {
					var r = requests[url] || (supportXDomainRequest ? new XDomainRequest() : new XMLHttpRequest());
					if (r._timeout) clearTimeout(r._timeout);
					r._timeout = setTimeout(function(){
						r.abort();
					}, timeout);
					r.onload = function(){
						clearTimeout(this._timeout);
						delete requests[url];
						try {
							success(JSON.parse(this.responseText));
						} catch(e){
							error(e);
						}
					};
					r.onerror = r.onabort = r.ontimeout = function(e){
						clearTimeout(this._timeout);
						delete requests[url];
						error(e);
					};
					if (r.readyState <= 1 || supportXDomainRequest){ // XDomainRequest doesn't have readyState
						r.open('GET', url + '?' + date(), true);
						r.send();
					}
					requests[url] = r;
				}
			} else {
				// Very, very basic JSON-P fallback
				var d = w.document,
					s = d.createElement('script'),
					callback = 'callback' + date();
				w[callback] = success;
				s.onerror = error;
				s.src = url + '?callback=' + callback;
				d.body.appendChild(s);
			}
		};

	var urls = [
		'http://node-hnapi-eu.herokuapp.com/', // Heroku (EU)
		'http://node-hnapi.azurewebsites.net/', // Windows Azure (North EU)
		'http://node-hnapi-asia.azurewebsites.net/', // Windows Azure (East Asia)
		'http://node-hnapi-eus.azurewebsites.net/', // Windows Azure (East US)
		'http://node-hnapi-weu.azurewebsites.net/', // Windows Azure (West EU)
		'http://node-hnapi-wus.azurewebsites.net/', // Windows Azure (West US)
		'http://node-hnapi-ncus.azurewebsites.net/' // Windows Azure (North Central US)
	];
	var shuffle = function(array){ // Fisher-Yates
		for (var i = array.length - 1; i > 0; i--){
			var j = Math.floor(Math.random() * (i + 1));
			var temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	};
	shuffle(urls);

	var length = urls.length;
	var reqAgain = function(i, path, success, error){
		var errorFunc = (i < length-1) ? function(){
			reqAgain(i+1, path, success, error);
		} : error;
		req(urls[i] + path, success, errorFunc);
	};
	var reqs = function(path, success, error){
		req(urls[0] + path, success, function(){
			reqAgain(0, path, success, error);
		});
	};
	
	var hnapi = {
		
		urls: urls,

		news: function(success, error){
			reqs('news', success, error);
		},
		
		news2: function(success, error){
			reqs('news2', success, error);
		},
		
		item: function(id, success, error){
			reqs('item/' + id, success, error);
		},

		comments: function(id, success, error){
			reqs('comments/' + id, success, error);
		}
		
	};
	
	w.hnapi = hnapi;
	
})(window);;/*!
 * ibento.js, super duper simple event delegation
 *
 * Copyright 2012, Lim Chee Aun (http://cheeaun.com/)
 * Licensed under the MIT license.
 * http://cheeaun.mit-license.org/
 */

(function(w){
	var d = w.document,
		matchesSelector = function(node, selector){
			var root = d.documentElement,
			matches = root.matchesSelector || root.mozMatchesSelector || root.webkitMatchesSelector || root.oMatchesSelector || root.msMatchesSelector;
			return matches.call(node, selector);
		},
		closest = function(node, selector){
			var matches = false;
			do {
				matches = matchesSelector(node, selector);
			} while (!matches && (node = node.parentNode) && node.ownerDocument);
			return matches ? node : false;
		};

	w.ibento = function(selector, event, fn){
		var body = d.body;
		body.addEventListener(event, function(e){
			var target = closest(e.target, selector);
			if (!target) return;
			fn.call(body, e, target);
		});
	};

})(window);;/*
 * classList.js: Cross-browser full element.classList implementation.
 * 2012-11-15
 *
 * By Eli Grey, http://eligrey.com
 * Public Domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/

if (typeof document !== "undefined" && !("classList" in document.createElement("a"))) {

(function (view) {

"use strict";

if (!('HTMLElement' in view) && !('Element' in view)) return;

var
	  classListProp = "classList"
	, protoProp = "prototype"
	, elemCtrProto = (view.HTMLElement || view.Element)[protoProp]
	, objCtr = Object
	, strTrim = String[protoProp].trim || function () {
		return this.replace(/^\s+|\s+$/g, "");
	}
	, arrIndexOf = Array[protoProp].indexOf || function (item) {
		var
			  i = 0
			, len = this.length
		;
		for (; i < len; i++) {
			if (i in this && this[i] === item) {
				return i;
			}
		}
		return -1;
	}
	// Vendors: please allow content code to instantiate DOMExceptions
	, DOMEx = function (type, message) {
		this.name = type;
		this.code = DOMException[type];
		this.message = message;
	}
	, checkTokenAndGetIndex = function (classList, token) {
		if (token === "") {
			throw new DOMEx(
				  "SYNTAX_ERR"
				, "An invalid or illegal string was specified"
			);
		}
		if (/\s/.test(token)) {
			throw new DOMEx(
				  "INVALID_CHARACTER_ERR"
				, "String contains an invalid character"
			);
		}
		return arrIndexOf.call(classList, token);
	}
	, ClassList = function (elem) {
		var
			  trimmedClasses = strTrim.call(elem.className)
			, classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
			, i = 0
			, len = classes.length
		;
		for (; i < len; i++) {
			this.push(classes[i]);
		}
		this._updateClassName = function () {
			elem.className = this.toString();
		};
	}
	, classListProto = ClassList[protoProp] = []
	, classListGetter = function () {
		return new ClassList(this);
	}
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
	return this[i] || null;
};
classListProto.contains = function (token) {
	token += "";
	return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
	;
	do {
		token = tokens[i] + "";
		if (checkTokenAndGetIndex(this, token) === -1) {
			this.push(token);
			updated = true;
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.remove = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
	;
	do {
		token = tokens[i] + "";
		var index = checkTokenAndGetIndex(this, token);
		if (index !== -1) {
			this.splice(index, 1);
			updated = true;
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.toggle = function (token, forse) {
	token += "";

	var
		  result = this.contains(token)
		, method = result ?
			forse !== true && "remove"
		:
			forse !== false && "add"
	;

	if (method) {
		this[method](token);
	}

	return !result;
};
classListProto.toString = function () {
	return this.join(" ");
};

if (objCtr.defineProperty) {
	var classListPropDesc = {
		  get: classListGetter
		, enumerable: true
		, configurable: true
	};
	try {
		objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	} catch (ex) { // IE 8 doesn't support enumerable:true
		if (ex.number === -0x7FF5EC54) {
			classListPropDesc.enumerable = false;
			objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
		}
	}
} else if (objCtr[protoProp].__defineGetter__) {
	elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

}
;(function(t){
	TEMPLATES = {
		'comments-toggle': new t({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<button class=\"comments-toggle\">");t.b(t.v(t.f("comments_count",c,p,0)));t.b(" ");t.b(t.v(t.f("i_reply",c,p,0)));t.b("</button>");return t.fl(); },partials: {}, subs: {  }}),
		'comments': new t({code: function (c,p,i) { var t=this;t.b(i=i||"");if(t.s(t.f("comments",c,p,1),c,p,0,13,189,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<li><p class=\"metadata\"><b>");t.b(t.v(t.f("user",c,p,0)));t.b("</b> <time><a href=\"#\" data-id=\"");t.b(t.v(t.f("id",c,p,0)));t.b("\" class=\"comment-permalink\">");t.b(t.v(t.f("time_ago",c,p,0)));t.b("</a></time></p><p>");t.b(t.t(t.f("content",c,p,0)));t.b("<ul>");t.b(t.rp("<comments_list0",c,p,""));t.b("</ul></li>");});c.pop();}return t.fl(); },partials: {"<comments_list0":{name:"comments_list", partials: {}, subs: {  }}}, subs: {  }}),
		'post-comments': new t({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div class=\"post-content\">");if(t.s(t.f("has_post",c,p,1),c,p,0,39,577,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<header><h1><a href=\"");t.b(t.v(t.f("url",c,p,0)));t.b("\" target=\"_blank\">");t.b(t.v(t.f("title",c,p,0)));t.b("<br>");if(t.s(t.f("user",c,p,1),c,p,0,107,170,"{{ }}")){t.rs(c,p,function(c,p,t){if(t.s(t.f("domain",c,p,1),c,p,0,118,159,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<span class=\"link-text\">");t.b(t.v(t.f("domain",c,p,0)));t.b("</span>");});c.pop();}});c.pop();}t.b("</a></h1><p class=\"metadata\">");if(t.s(t.f("user",c,p,1),c,p,0,217,412,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<span class=\"inline-block\">");t.b(t.v(t.f("points",c,p,0)));t.b(" ");t.b(t.v(t.f("i_point",c,p,0)));t.b(" by ");t.b(t.v(t.f("user",c,p,0)));t.b("</span> <span class=\"inline-block\">");t.b(t.v(t.f("time_ago",c,p,0)));if(t.s(t.f("comments_count",c,p,1),c,p,0,344,386,"{{ }}")){t.rs(c,p,function(c,p,t){t.b(" &middot; ");t.b(t.v(t.f("comments_count",c,p,0)));t.b(" ");t.b(t.v(t.f("i_comment",c,p,0)));});c.pop();}t.b("</span>");});c.pop();}if(!t.s(t.f("user",c,p,1),c,p,1,0,0,"")){t.b("<span class=\"inline-block\">");t.b(t.v(t.f("time_ago",c,p,0)));t.b("</span>");};t.b("<a href=\"");t.b(t.v(t.f("hn_url",c,p,0)));t.b("\" target=\"_blank\" class=\"external-link\">");t.b(t.v(t.f("short_hn_url",c,p,0)));t.b("</a></p></header>");});c.pop();}if(t.s(t.f("has_content",c,p,1),c,p,0,606,929,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<section class=\"grouped-tableview\">");t.b(t.t(t.f("content",c,p,0)));if(t.s(t.f("has_poll",c,p,1),c,p,0,667,906,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<ul class=\"poll\">");if(t.s(t.f("poll",c,p,1),c,p,0,693,892,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<li title=\"");t.b(t.v(t.f("percentage",c,p,0)));t.b("%\"><span class=\"poll-details\"><b>");t.b(t.v(t.f("item",c,p,0)));t.b("</b> <span class=\"points\">");t.b(t.v(t.f("points",c,p,0)));t.b(" ");t.b(t.v(t.f("i_point",c,p,0)));t.b("</span></span><div class=\"poll-bar\"><span style=\"width: ");t.b(t.v(t.f("width",c,p,0)));t.b("\"></span></div></li>");});c.pop();}t.b("</ul>");});c.pop();}t.b("</section>");});c.pop();}t.b("</div><section class=\"comments\">");if(t.s(t.f("loading",c,p,1),c,p,0,989,1030,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<div class=\"loader\">Loading&hellip;</div>");});c.pop();}if(t.s(t.f("load_error",c,p,1),c,p,0,1057,1140,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<div class=\"load-error\">Couldn't load comments.<br><button>Try again</button></div>");});c.pop();}if(!t.s(t.f("loading",c,p,1),c,p,1,0,0,"")){if(!t.s(t.f("load_error",c,p,1),c,p,1,0,0,"")){if(t.s(t.f("has_comments",c,p,1),c,p,0,1199,1226,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<ul>");t.b(t.rp("<comments_list0",c,p,""));t.b("</ul>");});c.pop();}if(!t.s(t.f("has_comments",c,p,1),c,p,1,0,0,"")){t.b("<p class=\"no-comments\">No comments.</p>");};};};t.b("</section>");return t.fl(); },partials: {"<comments_list0":{name:"comments_list", partials: {}, subs: {  }}}, subs: {  }}),
		'post': new t({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<li id=\"story-");t.b(t.v(t.f("id",c,p,0)));t.b("\" data-index=\"");t.b(t.v(t.f("i",c,p,0)));t.b("\" class=\"post-");t.b(t.v(t.f("type",c,p,0)));t.b("\"><a href=\"");t.b(t.v(t.f("url",c,p,0)));t.b("\" class=\"");if(t.s(t.f("detail_disclosure",c,p,1),c,p,0,110,127,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("detail-disclosure");});c.pop();}if(t.s(t.f("disclosure",c,p,1),c,p,0,164,174,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("disclosure");});c.pop();}t.b(" ");if(t.s(t.f("selected",c,p,1),c,p,0,203,211,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("selected");});c.pop();}t.b("\"><div class=\"number\">");t.b(t.v(t.f("i",c,p,0)));t.b(".</div><div class=\"story\"><b>");t.b(t.v(t.f("title",c,p,0)));t.b("</b>");if(t.s(t.f("user",c,p,1),c,p,0,302,594,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<span class=\"metadata\">");if(t.s(t.f("domain",c,p,1),c,p,0,336,381,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<span class=\"link-text\">");t.b(t.v(t.f("domain",c,p,0)));t.b("</span><br>");});c.pop();}t.b("<span class=\"inline-block\">");t.b(t.v(t.f("points",c,p,0)));t.b(" ");t.b(t.v(t.f("i_point",c,p,0)));t.b(" by ");t.b(t.v(t.f("user",c,p,0)));t.b("</span> <span class=\"inline-block\">");t.b(t.v(t.f("time_ago",c,p,0)));if(t.s(t.f("comments_count",c,p,1),c,p,0,519,561,"{{ }}")){t.rs(c,p,function(c,p,t){t.b(" &middot; ");t.b(t.v(t.f("comments_count",c,p,0)));t.b(" ");t.b(t.v(t.f("i_comment",c,p,0)));});c.pop();}t.b("</span></span>");});c.pop();}if(!t.s(t.f("user",c,p,1),c,p,1,0,0,"")){t.b("<span class=\"metadata\">");if(t.s(t.f("domain",c,p,1),c,p,0,646,691,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<span class=\"link-text\">");t.b(t.v(t.f("domain",c,p,0)));t.b("</span><br>");});c.pop();}t.b("<span class=\"inline-block\">");t.b(t.v(t.f("time_ago",c,p,0)));t.b("</span></span>");};t.b("</div></a>");if(t.s(t.f("detail_disclosure",c,p,1),c,p,0,796,870,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<a href=\"#/item/");t.b(t.v(t.f("id",c,p,0)));t.b("\" class=\"detail-disclosure-button\"><span></span></a>");});c.pop();}t.b("</li>");return t.fl(); },partials: {}, subs: {  }}),
		'stories-load': new t({code: function (c,p,i) { var t=this;t.b(i=i||"");if(t.s(t.f("loading",c,p,1),c,p,0,12,53,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<div class=\"loader\">Loading&hellip;</div>");});c.pop();}if(t.s(t.f("load_error",c,p,1),c,p,0,80,132,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("<div class=\"load-error\">Couldn't load stories.</div>");});c.pop();}return t.fl(); },partials: {}, subs: {  }})
	}
})(Hogan.Template);;(function(w){
	var d = w.document;

	var $ = w.$ = function(id){
		return d.getElementById(id);
	};

	var pubsubCache = {},
		clone = function(obj){
			var target = {};
			for (var i in obj){
				if (obj.hasOwnProperty(i)) target[i] = obj[i];
			}
			return target;
		};

	var hw = {
		// PubSub
		pub: function(topic, data){
			var t = pubsubCache[topic];
			if (!t) return;
			for (var i=0, l=t.length; i<l; i++){
				t[i].call(this, data);
			}
		},
		sub: function(topic, fn){
			if (!pubsubCache[topic]) pubsubCache[topic] = [];
			pubsubCache[topic].push(fn);
		},
		currentView: null,
		hideAllViews: function(){
			var views = d.querySelectorAll('.view');
			for (var i=0, l=views.length; i<l; i++){
				views[i].classList.add('hidden');
			}
		},
		tmpl: function(template, data){
			var t = TEMPLATES[template];
			if (!t) return;
			if (!data) return t;
			return t.render(data);
		},
		setTitle: function(str){
			var title = 'HackerWeb';
			if (str){
				str = str.replace(/^\s+|\s+$/g, ''); // trim
				if (str.toLowerCase() != title.toLowerCase()){
					title = str + ' – ' + title;
				}
			}
			document.title = title;
		}
	};

	// Log API failures/errors to GA
	if (typeof _gaq != 'undefined') hw.sub('logAPIError', function(type){
		_gaq.push(['_trackEvent', 'Errors', 'API', type]);
	});

	var tmpl = hw.tmpl;

	// Fix browsers freak out of amplify.store.sessionStorage not a function
	if (!amplify.store.sessionStorage || typeof amplify.store.sessionStorage != 'function'){
		amplify.store.sessionStorage = amplify.store.memory; // Fallback to in-memory storage
	}

	var $homeScroll = d.querySelector('#view-home .scroll'),
		$homeScrollSection = $homeScroll.querySelector('section'),
		loadingNews = false;

	hw.news = {
		options: {
			disclosure: true
		},
		markupStory: function(item){
			if (/^item/i.test(item.url)){
				item.url = '#/item/' + item.id;
			} else {
				item.external = true;
				var a = d.createElement('a');
				a.href = item.url;
				item.domain = a.hostname.replace(/^www\./, '');
				delete a;
			}
			if (!hw.news.options.disclosure){
				if (item.id) item.url = '#/item/' + item.id;
			} else {
				if (item.type == 'link') item.detail_disclosure = true;
				if (/^#\//.test(item.url)){
					item.disclosure = true;
					item.domain = null;
				}
			}
			item.i_point = item.points == 1 ? 'point' : 'points';
			item.i_comment = item.comments_count == 1 ? 'comment' : 'comments';
			return tmpl('post', item);
		},
		markupStories: function(data, i){
			var html = '';
			if (!i) i = 1;
			var markupStory = hw.news.markupStory;
			data.forEach(function(item){
				item.i = i++;
				html += markupStory(item);
			});
			return html;
		},
		// Re-markup the story item in the News list when
		// there's an update from specific API call of the item.
		// Make sure the title, points, comments count, etc matches.
		updateStory: function(story){
			if (!story || !story.id) return;
			var id = story.id;
			var data = story.data;
			var post;
			var newsCache = 'hacker-news';
			var news = amplify.store(newsCache);
			if (news){
				for (var i=0, l=news.length; i<l; i++){
					var p = news[i];
					if (id == p.id){
						post = p;
						break;
					}
				}
			}
			if (!post){
				newsCache = 'hacker-news2';
				news = amplify.store(newsCache);
				if (news){
					for (var i=0, l=news.length; i<l; i++){
						var p = news[i];
						if (id == p.id){
							post = p;
							break;
						}
					}
				}
			}
			if (!post) return;
			// Pass in the possibly changed values
			var changed = false;
			['title', 'url',  'time_ago', 'comments_count', 'points'].forEach(function(key){
				var val = data[key];
				if (post[key] != val){
					post[key] = val;
					changed = true;
				}
			});
			if (!changed) return;
			// Update the news cache
			amplify.store(newsCache, news);
			// Update the story in the news list
			var storyEl = $('story-' + id);
			if (!storyEl) return;
			post.selected = !!storyEl.querySelector('a[href].selected');
			post.i = storyEl.dataset ? storyEl.dataset.index : storyEl.getAttribute('data-index');
			storyEl.insertAdjacentHTML('afterend', hw.news.markupStory(post));
			storyEl.parentNode.removeChild(storyEl);
		},
		render: function(opts){
			if (loadingNews) return;
			if (!opts) opts = {};
			var cached = amplify.store('hacker-news-cached');
			var tmpl1 = tmpl('stories-load');
			var loadNews = function(_data){
				var data = _data.slice();
				var html = '<ul class="tableview tableview-links" id="hwlist">'
					+ hw.news.markupStories(data)
					+ (amplify.store('hacker-news2') ? '<li><a class="more-link">More&hellip;<span class="loader"></span></a></li>' : '')
					+ '</ul>';
				$homeScrollSection.innerHTML = html;
				hw.pub('onRenderNews');
			};
			if (cached){
				var news = amplify.store('hacker-news');
				var delay = opts.delay;
				if (delay){
					loadingNews = true;
					$homeScrollSection.innerHTML = tmpl1.render({loading: true});
					setTimeout(function(){
						loadingNews = false;
						loadNews(news);
					}, delay);
				} else {
					loadNews(news);
				}
			} else {
				loadingNews = true;
				$homeScrollSection.innerHTML = tmpl1.render({loading: true});
				var showError = function(){
					$homeScrollSection.innerHTML = tmpl1.render({load_error: true});
					hw.pub('logAPIError', 'news');
				};
				hnapi.news(function(data){
					loadingNews = false;
					if (!data || data.error){
						showError();
						return;
					}
					amplify.store('hacker-news', data);
					amplify.store('hacker-news-cached', true, {
						expires: 1000*60*10 // 10 minutes
					});
					amplify.store('hacker-news2', null);
					loadNews(data);
					// Preload news2 to prevent discrepancies between /news and /news2 results
					hnapi.news2(function(data){
						if (!data || data.error) return;
						amplify.store('hacker-news2', data);
						$('hwlist').insertAdjacentHTML('beforeend', '<li><a class="more-link">More&hellip;<span class="loader"></span></a></li>');
					});
				}, function(e){
					loadingNews = false;
					showError();
				});
			}
		},
		reload: function(){
			hw.news.render({
				delay: 300 // Cheat a little to make user think that it's doing something
			});
		},
		more: function(target){
			target.classList.add('loading');
			var news2 = amplify.store('hacker-news2');
			setTimeout(function(){
				target.classList.remove('loading');
				var targetParent = target.parentNode;
				if (!targetParent) return;
				if (targetParent.parentNode) targetParent.parentNode.removeChild(targetParent);
				if (!news2) return;
				var data = news2.slice();
				var html = hw.news.markupStories(data, 31);
				$('hwlist').insertAdjacentHTML('beforeend', html);
			}, 400);
		}
	};

	var $commentsView = $('view-comments'),
		$commentsHeading = $commentsView.querySelector('header h1'),
		$commentsSection = $commentsView.querySelector('section');

	hw.comments = {
		currentID: null,
		render: function(id){
			if (!id) return;
			var post = amplify.store.sessionStorage('hacker-item-' + id);
			if (hw.comments.currentID == id && post) return;
			hw.comments.currentID = id;

			var loadComments = function(_data, id){
					if (!_data || _data.error) return;
					var data = clone(_data);
					amplify.store.sessionStorage('hacker-comments-' + id, data);
					var ul = $commentsSection.querySelector('.comments>ul');
					if (!ul.querySelector('.more-link-container')){
						ul.insertAdjacentHTML('beforeend', '<li class="more-link-container"><a class="more-link" data-id="' + id + '">More&hellip;</a></li>');
					}
					if (!data.more_comments_id) return;

					// Preload all 'More' comments
					var loadMoreComments = function(id){
						var comments = amplify.store.sessionStorage('hacker-comments-' + id);
						if (!comments){
							hnapi.comments(id, function(data){
								if (!data || data.error) return;
								amplify.store.sessionStorage('hacker-comments-' + id, data);
								if (data.more_comments_id) loadMoreComments(data.more_comments_id);
							});
						} else {
							if (comments.more_comments_id) loadMoreComments(comments.more_comments_id);
						}
					};
					loadMoreComments(data.more_comments_id);
				},
				loadPost = function(_data, id){
					var data = clone(_data),
						tmpl1 = tmpl('post-comments');

					data.has_post = !!data.title;
					if (!data.has_post){
						hw.setTitle();
						$commentsHeading.innerHTML = '';
						$commentsSection.innerHTML = tmpl1.render(data);
						hw.pub('adjustCommentsSection');
						hw.pub('onRenderComments');
						return;
					}

					var tmpl2 = tmpl('comments'),
						a = d.createElement('a');
					// If "local" link, link to Hacker News web site
					if (/^item/i.test(data.url)){
						data.url = 'http://news.ycombinator.com/' + data.url;
					} else {
						a.href = data.url;
						data.domain = a.hostname.replace(/^www\./, '');
					}
					data.has_comments = data.comments && !!data.comments.length;
					data.i_point = data.points == 1 ? 'point' : 'points';
					data.i_comment = data.comments_count == 1 ? 'comment' : 'comments';
					data.has_content = !!data.content;
					if (data.poll){
						var total = 0;
						var max = 0;
						data.poll.forEach(function(p){
							var points = p.points;
							if (points > max) max = points;
							total += points;
							p.i_point = points == 1 ? 'point' : 'points';
						});
						data.poll.forEach(function(p){
							var points = p.points;
							p.percentage = (points/total*100).toFixed(1);
							p.width = (points/max*100).toFixed(1) + '%';
						});
						data.has_poll = data.has_content = true;
					}
					data.short_hn_url = 'news.ycombinator.com/item?id=' + id;
					data.hn_url = 'http://' + data.short_hn_url;
					hw.setTitle(data.title);
					$commentsHeading.innerHTML = data.title;

					var html = tmpl1.render(data, {comments_list: tmpl2});
					var div = d.createElement('div');
					div.innerHTML = html;

					// Make all links open in new tab/window
					// If it's a comment permalink, link to HN
					var links = div.querySelectorAll('a');
					for (var i=0, l=links.length; i<l; i++){
						var link = links[i];
						if (link.classList.contains('comment-permalink')){
							var id = link.dataset ? link.dataset.id : link.getAttribute('data-id');
							link.href = 'http://news.ycombinator.com/item?id=' + id;
						}
						link.target = '_blank';
					}

					// 20K chars will be the max to trigger collapsible comments.
					// I can use number of comments as the condition but some comments
					// might have too many chars and make the page longer.
					if (html.length > 20000){
						var subUls = div.querySelectorAll('.comments>ul>li>ul');
						var tmpl3 = tmpl('comments-toggle');
						for (var j=0, l=subUls.length; j<l; j++){
							var subUl = subUls[j],
								commentsCount = subUl.querySelectorAll('.metadata').length;
							subUl.style.display = 'none';
							if (commentsCount){
								subUl.insertAdjacentHTML('beforebegin', tmpl3.render({
									comments_count: commentsCount,
									i_reply: commentsCount == 1 ? 'reply' : 'replies'
								}));
							}
						}
					}

					while ($commentsSection.hasChildNodes()){
						$commentsSection.removeChild($commentsSection.childNodes[0]);
					}
					while (div.hasChildNodes()){
						$commentsSection.appendChild(div.childNodes[0]);
					}
					delete div;

					// Grab 'More' comments
					if (data.more_comments_id){
						var id = data.more_comments_id;
						var comments = amplify.store.sessionStorage('hacker-comments-' + id);
						if (comments){
							loadComments(comments, id);
						} else {
							hnapi.comments(id, function(data){
								loadComments(data, id);
							});
						}
					}

					hw.pub('onRenderComments');
				};

			if (post){
				$commentsSection.scrollTop = 0;
				loadPost(post, id);
			} else {
				// Render the post data concurrently while loading the comments
				// if the data is in 'news' or 'news2' cache
				var news = amplify.store('hacker-news');
				if (news){
					for (var i=0, l=news.length; i<l; i++){
						var p = news[i];
						if (id == p.id){
							post = p;
							break;
						}
					}
				}
				if (!post){
					var news = amplify.store('hacker-news2');
					if (news){
						for (var i=0, l=news.length; i<l; i++){
							var p = news[i];
							if (id == p.id){
								post = p;
								break;
							}
						}
					}
				}
				if (post){
					post.loading = true;
					loadPost(post, id);
				} else {
					loadPost({loading: true}, id);
				}
				var showError = function(){
					if (post){
						delete post.loading;
						post.load_error = true;
						loadPost(post, id);
					} else {
						loadPost({load_error: true}, id);
					}
					hw.pub('logAPIError', 'comments');
				};
				hnapi.item(id, function(data){
					// Avoiding the case where the wrong post is loaded when connection is slow
					if (hw.comments.currentID != id) return;

					if (!data || data.error && hw.currentView == 'comments'){
						showError();
						return;
					}
					amplify.store.sessionStorage('hacker-item-' + id, data, {
						expires: 1000*60*5 // 5 minutes
					});
					// Sync the story to the one listed in the stories list
					hw.news.updateStory({
						id: id,
						data: data
					});
					loadPost(data, id);
				}, function(e){
					if (hw.comments.currentID != id) return;
					showError();
				});
			}
		},
		toggle: function(target){
			var ul = target.nextElementSibling;
			if (ul){
				var ulStyle = ul.style;
				// Fix weird bug introduced in iOS6
				// Toggling this button somehow make the content scroll to top.
				var top = $commentsSection.scrollTop;
				ulStyle.display = (ulStyle.display == 'none') ? '' : 'none';
				$commentsSection.scrollTop = top;
			}
		},
		more: function(target){
			var id = target.dataset ? target.dataset.id : target.getAttribute('data-id');
			var comments = amplify.store.sessionStorage('hacker-comments-' + id);
			if (comments){
				var tmpl1 = tmpl('comments'),
					tmpl2 = tmpl('comments'),
					html = tmpl1.render(comments, {comments_list: tmpl1}),
					li = target.parentNode,
					ul = li.parentNode,
					more_comments_id = comments.more_comments_id,
					_ul = d.createElement('ul');

				_ul.innerHTML = html;

				var links = _ul.querySelectorAll('a');
				for (var i=0, l=links.length; i<l; i++){
					links[i].target = '_blank';
				}

				var subLis = _ul.children;
				for (var i=0, l=subLis.length; i<l; i++){
					var subUl = subLis[i].getElementsByTagName('ul')[0];
					var commentsCount = subUl.querySelectorAll('.metadata').length;
					subUl.style.display = 'none';
					if (commentsCount){
						subUl.insertAdjacentHTML('beforebegin', tmpl2.render({
							comments_count: commentsCount,
							i_reply: commentsCount == 1 ? 'reply' : 'replies'
						}));
					}
				}

				if (more_comments_id && amplify.store.sessionStorage('hacker-comments-' + more_comments_id)){
					_ul.insertAdjacentHTML('beforeend', '<li class="more-link-container"><a class="more-link" data-id="' + more_comments_id + '">More&hellip;</a></li>');
				}
				ul.removeChild(li);
				while (_ul.hasChildNodes()){
					ul.appendChild(_ul.childNodes[0]);
				}
				delete _ul;
			} else {
				// TODO: Need funnier error message than this.
				alert('Oops, the comments have expired.');
			}
		},
		reload: function(){
			hw.comments.currentID = null;
			ruto.reload();
		}
	};

	hw.init = function(){
		hw.news.render();
		ruto.init();
	};

	w.hw = hw;

	ruto
		.config({
			before: function(path, name){
				hw.hideAllViews();
				var view = $('view-' + name);
				view.classList.remove('hidden');
				hw.currentView = name;
				hw.setTitle(view.querySelector('header h1').textContent);
			},
			notfound: function(){
				ruto.go('/');
			}
		})
		.add('/', 'home')
		.add('/about', 'about')
		.add(/^\/item\/(\d+)$/i, 'comments', function(path, id){
			hw.comments.render(id);
		});
})(window);;(function(w){
	if (!w.addEventListener) return; // If the browser doesn't even support this, just give up.

	var d = w.document,
		body = d.body,
		scrollTops = {},
		scrollTimeout,
		getScrollTop = function(){
			return w.pageYOffset || d.compatMode === 'CSS1Compat' && d.documentElement.scrollTop || body.scrollTop || 0;
		},
		saveScrollTop = function(){
			scrollTops[location.hash.slice(1)] = getScrollTop();
		};
	w.addEventListener('scroll', function(){
		// debouncing scrolls
		clearTimeout(scrollTimeout);
		scrollTimeout = setTimeout(saveScrollTop, 500);
	}, false);
	ruto.config({
		on: function(){
			var hash = location.hash.slice(1);
			w.scrollTo(0, scrollTops[hash] || 0);
			scrollTops[hash] = getScrollTop();
		}
	});

	// Adjust min-height on the views based on the viewport
	// While waiting for viewport units to be more widely supported by modern browsers
	var head = d.head || d.getElementsByTagName('head')[0];
	var adjustViewsHeight = function(){
		var vh = window.innerHeight;
		var style = $('view-height');
		if (!style){
			style = d.createElement('style');
			style.id = 'view-height';
			head.appendChild(style);
		}
		style.textContent = '.view>.scroll{min-height: ' + (vh*.85) + 'px}';
	};
	w.addEventListener('resize', adjustViewsHeight, false);
	w.addEventListener('orientationchange', adjustViewsHeight, false);
	adjustViewsHeight();

	ibento('#view-home-refresh', 'click', hw.news.reload);

	ibento('#view-home .more-link', 'click', function(e, target){
		hw.news.more(target);
	});

	ibento('button.comments-toggle', 'click', function(e, target){
		hw.comments.toggle(target);
	});

	ibento('section.comments li>a.more-link', 'click', function(e, target){
		hw.comments.more(target);
	});

	ibento('#view-comments .load-error button', 'click', hw.comments.reload);

	hw.init();
})(window);